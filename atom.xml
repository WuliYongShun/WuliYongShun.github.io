<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向北方</title>
  
  <subtitle>code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-23T14:02:20.601Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>不会飞的风</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-苦逼如我开始开发简介</title>
    <link href="http://yoursite.com/2019/11/23/Linux-%E8%8B%A6%E9%80%BC%E5%A6%82%E6%88%91%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/11/23/Linux-苦逼如我开始开发简介/</id>
    <published>2019-11-23T13:17:09.000Z</published>
    <updated>2019-11-23T14:02:20.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说说我自己吧！！"><a href="#说说我自己吧！！" class="headerlink" title="说说我自己吧！！"></a>说说我自己吧！！</h1><p>作为一个毕业1年的本科学生也就是我本人，自从毕业之后一直还从事着电子类相关行业，会使用AD画一些图、会使用keil和一些开源软件写单片机代码；每个月拿着不多的工资、干着并不创新又重复操作的工作、生活在一个三四线又没有足够资金定居城市。毕业这一年每天都感到巨大的压力，从一个一心想转软件的小白到妥协搞嵌入式的渣渣，但是吧生活总是要继续的，总不能让明天过得比今天差吧，所以呢要坚持学习，相信付出总会有回报，坚持！！！！</p><h1 id="说说为什么要学嵌入式linux"><a href="#说说为什么要学嵌入式linux" class="headerlink" title="说说为什么要学嵌入式linux"></a>说说为什么要学嵌入式linux</h1><p>为什么要学linux呢，首先linux是一个世界级别的开源系统咱们就不在BB了，linux技术除了主要应用在服务器设备中，还在嵌入式行业占有很大的市场，通俗的再说一下吧，现在整个嵌入式除了单片机就是linux了，然后呢单片机主要面对的额是低端市场居多，嵌入式长期占领高端市场。那我们一个五六七八九十流的小公司来说吧，一个设备跑单片机完全能够解决所有问题，那还要花费巨大的人力和资金将设备转成linux操作系统的设备，就是为了个宣传假装高大上很多而已。说了这么多其实都是客套的在说，因为这不符合我的初衷啊，俺可是真的是热爱喜欢呢，大学就开始学习linux操作系统，Ubuntu系统一直在玩就是一直没有用武之地导致自己二半吊子的啥也不行，这次借助正点原子和野火这波风气必须好好搞一搞这个linux。</p><h1 id="说说我的准备吧"><a href="#说说我的准备吧" class="headerlink" title="说说我的准备吧"></a>说说我的准备吧</h1><p>为了学这个操作系统我在一年之前就买了一块核心吧，基于Cotex-A53架构的全志A64芯片做的一块核心板，这大半年一直想点亮呢，又由于各种事情没有进行下去，拓展板画好了很久很久也一直没有投出去焊接出来成品，这次是真的下定决心了，所以呢我吧自己画的板子做了一批件也买了一批，暂时只是没有时间焊接，等哪天挑出来个大片的时间把板子搞定再慢慢调吧。同时呢，我又买了一块野火的I.MX6ULL的开发板，画了几百票（想想千万不要为了省钱而不花钱投资自己的学习，你现在的话费和付出在将来一定会几倍、几十倍、几百倍的汇报回来）。</p><h1 id="说说开发板的选择吧"><a href="#说说开发板的选择吧" class="headerlink" title="说说开发板的选择吧"></a>说说开发板的选择吧</h1><p>这个开发板我可是选了很久很久，主要在正点原子和野火两家之间进行选择。我好的衡量了下还是野火的更适合我吧，屏幕的驱动转接板可以自己画，主要板载HDMI不要LCD也照样能看效果。话说这两家的套路还是很神的呢，很芯片做成了邮票边很明显不能再次更换核心了，BTB板接和金手指的还要再等他一个月，不过呢我忍了，就是个买吧，先好好地铺垫学习下等到板子回来之后就可以直接上手开发学习了；前边说的这个都是野火的板子，他的三个版本还是给大家留下了选择的余地了，再说说正点原子的吧，这个板子真的是让我又爱又气，虽然留下了BTB的核心板（显然是为了日后升级），但是呢只有LCD的屏幕接口（还是被改良过的只能用他们家的LCD液晶屏，显然不划算），没有HDMI接口还需后续购买，唯一让我能说好的就只是发货快，还能开发4G模组了。综合两个比较呢，还是野火的开发板更适合我了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上内容多数都为自己的观点，本片文章只是留给以后的自己看，在以后的日子中要为自己的这个开始做一个收尾。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;说说我自己吧！！&quot;&gt;&lt;a href=&quot;#说说我自己吧！！&quot; class=&quot;headerlink&quot; title=&quot;说说我自己吧！！&quot;&gt;&lt;/a&gt;说说我自己吧！！&lt;/h1&gt;&lt;p&gt;作为一个毕业1年的本科学生也就是我本人，自从毕业之后一直还从事着电子类相关行业，会使用AD画
      
    
    </summary>
    
    
      <category term="Embedded system" scheme="http://yoursite.com/categories/Embedded-system/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown4 列表</title>
    <link href="http://yoursite.com/2019/10/14/Markdown4-%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/10/14/Markdown4-列表/</id>
    <published>2019-10-14T05:31:03.000Z</published>
    <updated>2019-10-14T05:31:53.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Markdown-列表"><a href="#1、Markdown-列表" class="headerlink" title="1、Markdown 列表"></a>1、Markdown 列表</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、Markdown-列表&quot;&gt;&lt;a href=&quot;#1、Markdown-列表&quot; class=&quot;headerlink&quot; title=&quot;1、Markdown 列表&quot;&gt;&lt;/a&gt;1、Markdown 列表&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 段落格式</title>
    <link href="http://yoursite.com/2019/10/14/Markdown3-%E6%AE%B5%E8%90%BD%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/14/Markdown3-段落格式/</id>
    <published>2019-10-14T05:08:16.000Z</published>
    <updated>2019-10-14T05:30:05.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Markdown-段落"><a href="#1、Markdown-段落" class="headerlink" title="1、Markdown 段落"></a>1、Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编写号文字就好， 段落的换行是使用两个以上的空格加上回车。  </p><p><img src="C:%5CUsers%5CS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571029888842.png" alt></p><p>也可以在段落后面使用一个空行来表示重新开始一个段落。</p><p><img src="C:%5CUsers%5CS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571029978682.png" alt="1571029978682"></p><h1 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h1><p>Markdown 可以使用以下几种字体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><p>显示效果如下所示（源码下可以查看格式）：</p><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h1 id="3、分割线"><a href="#3、分割线" class="headerlink" title="3、分割线"></a>3、分割线</h1><p>可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。写法如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span><span class="bullet">* *</span></span><br><span class="line"></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>显示效果如下所示（md下可以查看源码格式）：</p><hr><hr><hr><hr><hr><h1 id="4、删除线"><a href="#4、删除线" class="headerlink" title="4、删除线"></a>4、删除线</h1><p>如果段落上的文字需要添加删除线，只需要在文字两端加上两个波浪线’~~’即可，实例如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">你好</span><br><span class="line">~~你好~~</span><br></pre></td></tr></table></figure><p>显示效果如下所示：</p><p>hello<br>你好<br><del>你好</del>  </p><h1 id="5、下划线"><a href="#5、下划线" class="headerlink" title="5、下划线"></a>5、下划线</h1><p>下划线可以通过HTML的<u>标签来实现：</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面为带下划线显示内容&lt;u&gt;I am a good dog!!!&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>显示效果如下所示：</p><p>后面为带下划线显示内容<u>I am a good dog!!!</u>  </p><h1 id="6、脚注"><a href="#6、脚注" class="headerlink" title="6、脚注"></a>6、脚注</h1><p>脚注是对文本的补充说明。</p><p>Markdown脚注的格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^我是被脚注的部分]</span><br></pre></td></tr></table></figure><p>脚注实例如下用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先在文本后面添加脚注，想这样[^Haha]</span><br><span class="line">[^Haha]: 天道酬勤</span><br></pre></td></tr></table></figure><p>显示效果如下所示（鼠标悬停在第一个脚注上即可显示下面的脚注内容）：  </p><p>先在文本后面添加脚注，想这样<a href="天道酬勤">^Haha</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、Markdown-段落&quot;&gt;&lt;a href=&quot;#1、Markdown-段落&quot; class=&quot;headerlink&quot; title=&quot;1、Markdown 段落&quot;&gt;&lt;/a&gt;1、Markdown 段落&lt;/h1&gt;&lt;p&gt;Markdown 段落没有特殊的格式，直接编写号文字
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>C++中显式、隐式与explicit关键字</title>
    <link href="http://yoursite.com/2019/10/09/C++-%E4%B8%AD%E6%98%BE%E5%BC%8F%E3%80%81%E9%9A%90%E5%BC%8F%E4%B8%8Eexplicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/09/C++-中显式、隐式与explicit关键字/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:54:21.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-中显式、隐式与explicit关键字"><a href="#C-中显式、隐式与explicit关键字" class="headerlink" title="C++中显式、隐式与explicit关键字"></a>C++中显式、隐式与explicit关键字</h1><p><strong><em>1.隐式转换</em></strong><br>隐式转换，即编译器完成的转换，例如<br>int a = 1;<br>float b = 3;<br>float sum;<br>sum = a + b;//a是int类型，b是float类型；在编译的时候，编译器自动将int a转换成了float类型</p><p><strong><em>2.显式转换</em></strong><br>显式转换，即用户完成的转换，例如<br>float a = 1;<br>float b = 3;<br>int s;<br>s = (int)a + (int)b;//float类型的a与b被显示的(强制)转换成成为float数据类型</p><p>对于非数据的函数函数而言，例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> x;</span><br><span class="line">　　<span class="keyword">public</span>:</span><br><span class="line">　　　　A()&#123;x=<span class="number">0</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Create A:0"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">　　　　A(<span class="keyword">int</span> a)&#123;x=a;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Create A:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">　　　　~A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Delete A:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　A a1;</span><br><span class="line">　　A *a2=<span class="keyword">new</span> A(<span class="number">10</span>);</span><br><span class="line">　　<span class="keyword">delete</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序分析：<br>A a1；隐式的调用了A();<br>A *a2 = new A(10);对A()进行了重载，显式的调用了A(int a);</p><p><strong><em>3.explicit关键字</em></strong></p><p>explicit用于构造函数，抑制隐式转换的发生，防止出现误区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-中显式、隐式与explicit关键字&quot;&gt;&lt;a href=&quot;#C-中显式、隐式与explicit关键字&quot; class=&quot;headerlink&quot; title=&quot;C++中显式、隐式与explicit关键字&quot;&gt;&lt;/a&gt;C++中显式、隐式与explicit关键字&lt;/h1
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内联函数(C++ inline)</title>
    <link href="http://yoursite.com/2019/10/09/C++-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0(C++%20inline)/"/>
    <id>http://yoursite.com/2019/10/09/C++-内联函数(C++ inline)/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:54:13.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-内联函数-C-inline"><a href="#C-内联函数-C-inline" class="headerlink" title="C++内联函数(C++ inline)"></a>C++内联函数(C++ inline)</h1><p>使用函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销。</p><p>函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。</p><p>另外，函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址继续执行，这个过程也要耗费时间。</p><p>总之，使用函数调用语句和直接把函数中的代码重新抄写一遍相比，节省了人力，但是带来了程序运行时间上的额外开销。</p><p>一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。</p><p>作为特别注重程序执行效率，适合编写底层系统软件的高级程序设计语言，C++ 用 inline 关键字较好地解决了函数调用开销的问题。</p><p>在 C++ 中，可以在定义函数时，在返回值类型前面加上 inline 关键字。如： </p><pre><code>inline int Max (int a, int b){    if(a &gt;b)        return a;    return b;}</code></pre><p>增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。</p><p>有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。</p><p>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。</p><p>有时函数看上去很简单，例如只有一个包含一两条语句的循环，但该循环的执行次数可能很多，要消耗大量时间，那么这种情况也不适合将其实现为内联函数。</p><p>注意：的是，调用内联函数的语句前必须已经出现内联函数的定义（即整个数体），而不能只出现内联函数的声明！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-内联函数-C-inline&quot;&gt;&lt;a href=&quot;#C-内联函数-C-inline&quot; class=&quot;headerlink&quot; title=&quot;C++内联函数(C++ inline)&quot;&gt;&lt;/a&gt;C++内联函数(C++ inline)&lt;/h1&gt;&lt;p&gt;使用函数能够避免将相
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="http://yoursite.com/2019/10/09/C++-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/09/C++-函数/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:54:04.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。</p><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p><p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p><p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。</p><p>函数还有很多叫法，比如方法、子例程或程序，等等。</p><p><strong>函数定义格式</strong><br>C++ 中的函数定义的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p><pre><code>返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。函数主体：函数主体包含一组定义函数执行任务的语句。</code></pre><p><strong>实例</strong><br>以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：<br>//函数返回两个数中较大那个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int max( int num1, int num2 )</span><br><span class="line">&#123;</span><br><span class="line">    //局部变量声明</span><br><span class="line">    int result；</span><br><span class="line">    </span><br><span class="line">   if(num1 &gt; num2 )</span><br><span class="line">        result = num1;</span><br><span class="line">    else </span><br><span class="line">        result = num2;</span><br><span class="line">        </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数声明</strong><br>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。<br>函数声明包括以下几个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list );</span><br></pre></td></tr></table></figure><p>针对上面定义的函数 max()，以下是函数声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int max(int num1, int num2);</span><br></pre></td></tr></table></figure><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int max(int, int);</span><br></pre></td></tr></table></figure><p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p><p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p><p><strong>函数调用</strong><br>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。<br>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用函数来获取最大值</span></span><br><span class="line">   ret = max(a, b);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max value is : "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：<br>Max value is : 200</p><p><strong>函数参数</strong></p><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。<br>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。<br>当调用函数时，有两种向函数传递参数的方式：</p><p>调用类型：<br>传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。<br>指针调用：该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>引用调用：该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p><p>默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p><p><strong>参数的默认值</strong></p><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。<br>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = a + b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用函数来添加值</span></span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再次调用函数</span></span><br><span class="line">   result = sum(a);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>Total value is :300<br>Total value is :120</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-函数&quot;&gt;&lt;a href=&quot;#C-函数&quot; class=&quot;headerlink&quot; title=&quot;C++函数&quot;&gt;&lt;/a&gt;C++函数&lt;/h1&gt;&lt;p&gt;函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程</title>
    <link href="http://yoursite.com/2019/10/09/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/09/C++-多线程/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:53:38.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION CriticalSection;    <span class="comment">//防止共有资源被同时调用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;    <span class="comment">//定义一个变量初始值为10</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadOne</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"窗口1开始售票"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;CriticalSection);    <span class="comment">//进入临界状态</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"窗口1售出"</span> &lt;&lt; number;    <span class="comment">//打印出线程1抢占数值</span></span><br><span class="line">            number--;</span><br><span class="line">            Sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       LeaveCriticalSection(&amp;CriticalSection);    <span class="comment">//退出临界状态</span></span><br><span class="line">       Sleep(<span class="number">100</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadTwo</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"窗口2售票开始"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    EnterCriticalSection(&amp;CriticalSection);    <span class="comment">//进入线程临界状态</span></span><br><span class="line">    <span class="keyword">if</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"窗口2售出第"</span> &lt;&lt; number &lt;&lt; <span class="string">"张票"</span>；</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        number--;</span><br><span class="line">    &#125;</span><br><span class="line">    LeaveCriticalSection(&amp;CriticalSection);</span><br><span class="line">    Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE HOne,HTwo;</span><br><span class="line">    InitaializeCriticalSection(&amp;CriticalSection);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"*********vpoet******"</span>;</span><br><span class="line">    HOne = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadOne,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    HTwo = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadTwo,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(HOne);</span><br><span class="line">    CloseHandle(HTwo);</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"票没了！"</span></span><br><span class="line">            DeleCriticalSection(&amp;CriticalSection);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            coutinue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>构造函数和析构函数</title>
    <link href="http://yoursite.com/2019/10/09/C++-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/09/C++-构造函数和析构函数/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:53:55.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p><strong>构造函数</strong></p><p><strong>析构函数</strong><br>    构造函数（destructor）与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数用来做“清理善后”的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数和析构函数&quot;&gt;&lt;a href=&quot;#构造函数和析构函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数和析构函数&quot;&gt;&lt;/a&gt;构造函数和析构函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;析构函数&lt;
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Qt中C++中文显示</title>
    <link href="http://yoursite.com/2019/10/09/Qt-C++%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/10/09/Qt-C++中文显示/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:54:40.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt中C-中文显示"><a href="#Qt中C-中文显示" class="headerlink" title="Qt中C++中文显示"></a>Qt中C++中文显示</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;    //1.包含头文件</span></span></span><br><span class="line"></span><br><span class="line">QTextCodec *codec;     <span class="comment">//2声明一个全局变量</span></span><br><span class="line">codec = QtextCodec::codecForName(<span class="string">"GBK"</span>);    <span class="comment">//将编码格式声明为GBK</span></span><br><span class="line">ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode*(<span class="string">"中文"</span>));    <span class="comment">//将中文转换为为固定编码格式</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt中C-中文显示&quot;&gt;&lt;a href=&quot;#Qt中C-中文显示&quot; class=&quot;headerlink&quot; title=&quot;Qt中C++中文显示&quot;&gt;&lt;/a&gt;Qt中C++中文显示&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt中QLineEdit的使用</title>
    <link href="http://yoursite.com/2019/10/09/Qt-QLineEdit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/09/Qt-QLineEdit的使用/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:54:49.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QLineEdit的使用"><a href="#QLineEdit的使用" class="headerlink" title="QLineEdit的使用"></a>QLineEdit的使用</h1><p>定义：<br>        QLineEdit是一个单行文本编辑控件。<br>功能：<br>        可以调用多个可用函数，输入和编辑单行文本，比如撤销、恢复、剪切、粘贴及拖放等。</p><p>函数说明：<br>    echoMode()：可以设置其属性，比如一密码的形式输入；<br>    maxLength()：限制文本长度；<br>    validator()或inputMask()：限制智能输入数字，在对同一个QLineEdit的validator或者inputmask进行转换时，最好将它的validator或者inputmask清楚，以避免错误发生；</p><p>与QLineEdit相关的一个类QTextEdit，她允许多行文本以及富文本编辑：<br>    setText()或者insert()改变其中的文本;<br>    text()：获得文本；<br>    displayText()：获得显示的文本；<br>    setSelection()或者selectAll()选中文本；<br>    cut()、copy()、paste()函数可以对文本中的数据进行剪切、复制和粘贴；<br>    setAlignment()：设置文本为位置；</p><p>信号反馈：<br>    文本改变信号：textChange();<br>    不是由setText()造成文本的改变信号：textEdit();<br>    鼠标光标改变时信号：cursorPostionChanged()；<br>    返回键或者回车键按下时信号：returnPressed();</p><p>常用方法说明：</p><p>1.setPlaceholderText()设置提示文字<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205204407710-892374169.jpg" alt="文本框提示文字"><br>豆瓣电影的搜索输入框，没有输入任何字符时，显示“电影、影人、影院、电视剧”这些占位文字，对用户输入作相关提示。<br>echoLineEdit-&gt;setPlaceholderText(“电影、影人、影院、电视剧”);</p><p>2.setEchoMode()设置模式<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205223926663-818638865.jpg" alt="淘宝"><br>淘宝登录界面的一部分，用户名可以直接看到，密码一般都用小黑点掩盖。</p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//默认,输入什么即显示什么</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">QLineEdit</span>::Normal);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">//密码，一般用小黑点覆盖你所输入的字符</span></span><br><span class="line">             echoLineEdit-&gt;setEchoMode(<span class="attribute">QLineEdit</span>::Password);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">//编辑时输入字符显示输入内容否则用小黑点代替</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">QLintEdit</span>::PasswordEchoOnEdit);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">//任何输入都看不见（只是看不见，不是不能输入）</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">ALineEdit</span>::NoEcho);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.setAlignment()设置文本位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::Alignleft);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::AlignCenter);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::AlignRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.setReadOnly()设置能否编辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            accessLineEdit-&gt;setReadOnly(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            accessLineEdit-&gt;setReadOnly(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.setValidator()对输入进行限制<br>这种方式的是指是通过正则表达式限制输入内容<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205224628272-1758708857.jpg" alt="输入限制"></p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//无限制</span></span><br><span class="line">            validatorLineEdit-&gt;setValidator(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">//只能输入整数</span></span><br><span class="line">            validatorLineEdit-&gt;setValidator(<span class="keyword">new</span> QintValidator);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">//实例，只能输入-180到180之间的小数，小数点后最多两位（可用于限制经纬度等）</span></span><br><span class="line">            QDoubleValodator *pDfValidator = <span class="keyword">new</span> QDoubleValidator(<span class="number">-180</span>, <span class="number">180.0</span>, <span class="number">2</span>, validatorLineEdit);</span><br><span class="line">            pDfValidator-&gt;setNotation(<span class="attribute">QDoubleValidator</span>::StandardNotation);</span><br><span class="line">            validatorLineEdit-&gt;setValidator(pDfValidator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.setInputMask()对输入进行限制<br>通过限制格式限制输入，具体怎么格式化客气参考Qt助手。<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205213813663-1721525219.jpg" alt="对输入进行限制"></p><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"-99 99 99 99 99;_"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"0000-00-00"</span>);</span><br><span class="line">            inputMaskLineEdit-&gt;setText(<span class="string">"00000000"</span>);</span><br><span class="line">            inputMaskLineEdit-&gt;setCursorposition(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.setLength()设置可以输入的最多字符数<br>//最多只能输入9个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echoLineEdit-&gt;setMaxLength(9);</span><br></pre></td></tr></table></figure><p>8.validator和inputmask的结合<br>比如经纬度用“度”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;QLineEdit的使用&quot;&gt;&lt;a href=&quot;#QLineEdit的使用&quot; class=&quot;headerlink&quot; title=&quot;QLineEdit的使用&quot;&gt;&lt;/a&gt;QLineEdit的使用&lt;/h1&gt;&lt;p&gt;定义：&lt;br&gt;        QLineEdit是一个单行文
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用</title>
    <link href="http://yoursite.com/2019/10/09/Qt-QT_BEGIN_NAMESPACE%E5%92%8CQT_END_NAMESPACE%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/09/Qt-QT_BEGIN_NAMESPACE和QT_END_NAMESPACE的作用/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:21:15.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用"><a href="#Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用" class="headerlink" title="Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用"></a>Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用</h1><p> QT_BEGIN_NAMESPACE其实就是个宏，以前Qt4是没有命令空间的，后来才加上的，编译Qt源码时会有选项，是否将这些类放到专用的Qt命令空间内，默认是没有的。这就出来问题了，为了统一，如果你的代码在默认没有Qt命令空间的SDK中编译，那你就不用在前面加上命令空间，反之则需要。</p><p>为了屏蔽上面这个差异，使得你的代码能在这两种情况下都进行编译，Qt就提供了QT_BEGIN_NAMESPACE宏，这样开发者就省的自己来用程序或宏进行处理了。</p><p>至于说该宏提升编译速度什么的，那是上述类的声明的作用，与Qt无关的（也即与该宏QT_BEGIN_NAMESPACE无关），若要大幅提升编译速度需要开启qt的预编译头文件，会另起章节解说，并附测试结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PREVIEWWINDOW_H</span><br><span class="line"></span><br><span class="line">#define PREVIEWWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"><span class="comment">// 方式一:</span></span><br><span class="line">#include &lt;QTextBrowser&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"><span class="comment">// 方式二:    比方式一可轻微提升编译速度</span></span><br><span class="line">class QTextBrowser;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line"><span class="comment">// 方式三:    编译速度与方式二一样，该宏用于自编译qt源码是否启动命令空间的补充</span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line">class QTextBrowser;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">class <span class="attribute">PreviewWindow</span> : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    explicit PreviewWindow(QWidget *<span class="built_in">parent</span> = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">signals</span>:</span><br><span class="line"></span><br><span class="line">public <span class="attribute">slots</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // PREVIEWWINDOW_H</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用&quot;&gt;&lt;a href=&quot;#Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用&quot; class=&quot;headerlink&quot; title=&quot;Qt中QT_BEGI
      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt+sqlite数据库连接</title>
    <link href="http://yoursite.com/2019/10/09/Qt-sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/10/09/Qt-sqlite数据库连接/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:21:43.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt-sqlite数据库连接"><a href="#Qt-sqlite数据库连接" class="headerlink" title="Qt+sqlite数据库连接"></a>Qt+sqlite数据库连接</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt-sqlite数据库连接&quot;&gt;&lt;a href=&quot;#Qt-sqlite数据库连接&quot; class=&quot;headerlink&quot; title=&quot;Qt+sqlite数据库连接&quot;&gt;&lt;/a&gt;Qt+sqlite数据库连接&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt使Widget打开为全屏</title>
    <link href="http://yoursite.com/2019/10/09/Qt-%E4%BD%BFWidget%E6%89%93%E5%BC%80%E4%B8%BA%E5%85%A8%E5%B1%8F/"/>
    <id>http://yoursite.com/2019/10/09/Qt-使Widget打开为全屏/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:24:07.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt5-5-1使Widget打开为全屏"><a href="#Qt5-5-1使Widget打开为全屏" class="headerlink" title="Qt5.5.1使Widget打开为全屏"></a>Qt5.5.1使Widget打开为全屏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainWindow w;</span><br><span class="line">w.showMaximized();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt5-5-1使Widget打开为全屏&quot;&gt;&lt;a href=&quot;#Qt5-5-1使Widget打开为全屏&quot; class=&quot;headerlink&quot; title=&quot;Qt5.5.1使Widget打开为全屏&quot;&gt;&lt;/a&gt;Qt5.5.1使Widget打开为全屏&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt信号与槽</title>
    <link href="http://yoursite.com/2019/10/09/Qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
    <id>http://yoursite.com/2019/10/09/Qt-信号与槽/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:24:52.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><p>简介：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信号与槽&quot;&gt;&lt;a href=&quot;#信号与槽&quot; class=&quot;headerlink&quot; title=&quot;信号与槽&quot;&gt;&lt;/a&gt;信号与槽&lt;/h1&gt;&lt;p&gt;简介：&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt常用控件的创建和使用</title>
    <link href="http://yoursite.com/2019/10/09/Qt-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/09/Qt-常用控件的创建和使用/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:22:13.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用控件的创建和使用"><a href="#常用控件的创建和使用" class="headerlink" title="常用控件的创建和使用"></a>常用控件的创建和使用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;resize(<span class="number">600</span>,<span class="number">400</span>);  <span class="comment">//Set the window size</span></span><br><span class="line"></span><br><span class="line">    QMenuBar *bar = menuBar();  <span class="comment">//创建菜单栏,只能一个</span></span><br><span class="line">    setMenuBar(bar);    <span class="comment">//将菜单栏设置到窗口中</span></span><br><span class="line"></span><br><span class="line">    QMenu * fileMenu = bar-&gt;addMenu(<span class="string">"文件"</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;addMenu(<span class="string">"编辑"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加文件菜单项</span></span><br><span class="line">    QAction * createAction = fileMenu-&gt;addAction(<span class="string">"创建"</span>);</span><br><span class="line">    fileMenu-&gt;addSeparator();<span class="comment">//添加分割线</span></span><br><span class="line">    QAction * closeAction = fileMenu-&gt;addAction(<span class="string">"关闭"</span>);</span><br><span class="line">    fileMenu-&gt;addSeparator();<span class="comment">//添加分割线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加编辑菜单栏</span></span><br><span class="line">    QAction * copyAction = editMenu-&gt;addAction(<span class="string">"拷贝"</span>);</span><br><span class="line">    QAction * pasteAction = editMenu-&gt;addAction(<span class="string">"粘贴"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏 可以有很多个</span></span><br><span class="line">    QToolBar *toolBar = <span class="keyword">new</span> QToolBar(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将工具栏放入窗口中</span></span><br><span class="line">    addToolBar(Qt::LeftToolBarArea, toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只允许左右停靠</span></span><br><span class="line">    toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea</span><br><span class="line">                             | Qt::TopToolBarArea | Qt::BottomToolBarArea);</span><br><span class="line">    <span class="comment">//设置是否允许浮动</span></span><br><span class="line">    toolBar-&gt;setFloatable(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置是否允许移动</span></span><br><span class="line">    toolBar-&gt;setMovable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在工具栏中添加控件</span></span><br><span class="line">    QPushButton *btn = <span class="keyword">new</span> QPushButton(<span class="string">"按钮1"</span>,<span class="keyword">this</span>);</span><br><span class="line">    QPushButton *btn1 = <span class="keyword">new</span> QPushButton(<span class="string">"按钮2"</span>,<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;setStyleSheet(<span class="string">"QPushButton&#123;color:red&#125;"</span>);</span><br><span class="line">    QPushButton *btn2 = <span class="keyword">new</span> QPushButton(<span class="string">"按钮3"</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    toolBar-&gt;addWidget(btn);</span><br><span class="line">    toolBar-&gt;addSeparator();</span><br><span class="line">    toolBar-&gt;addWidget(btn1);</span><br><span class="line">    toolBar-&gt;addSeparator();</span><br><span class="line">    toolBar-&gt;addWidget(btn2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏，只有一个</span></span><br><span class="line">    QStatusBar * status = statusBar();</span><br><span class="line">    <span class="comment">//将状态栏放入到窗口中</span></span><br><span class="line">    setStatusBar(status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建标签</span></span><br><span class="line">    QLabel * label1 = <span class="keyword">new</span> QLabel(<span class="string">"左侧信息"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将label放入到状态栏中</span></span><br><span class="line">    status-&gt;addWidget(label1);</span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> QLabel(<span class="string">"右侧信息"</span>, <span class="keyword">this</span>);</span><br><span class="line">    status-&gt;addPermanentWidget(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 浮动窗口 可以多个</span></span><br><span class="line">    QDockWidget * dock = <span class="keyword">new</span> QDockWidget(<span class="string">"铆接部件"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将铆接部件放到窗体的核心部件的下方</span></span><br><span class="line">    addDockWidget(Qt::BottomDockWidgetArea, dock);</span><br><span class="line">    <span class="comment">//铆接部件设置停靠范文</span></span><br><span class="line">    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建核心部件 只能有一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> QTextEdit(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将文本编辑 放到窗体中间</span></span><br><span class="line">    setCentralWidget(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：直接使用set方法的窗口中只能有一个，使用add方法的窗口中可以有很多个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用控件的创建和使用&quot;&gt;&lt;a href=&quot;#常用控件的创建和使用&quot; class=&quot;headerlink&quot; title=&quot;常用控件的创建和使用&quot;&gt;&lt;/a&gt;常用控件的创建和使用&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt设置背景界面</title>
    <link href="http://yoursite.com/2019/10/09/Qt-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/10/09/Qt-设置背景界面/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:23:42.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt设置背景界面"><a href="#Qt设置背景界面" class="headerlink" title="Qt设置背景界面"></a>Qt设置背景界面</h1><p>1.设置背景图片的一种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(QString::fromUtf8(<span class="string">"./icon/background.png"</span>))</span></span>;<span class="comment">//当前文件夹下面的图片</span></span><br><span class="line">QPalette palette = <span class="keyword">this</span>-&gt;palette();</span><br><span class="line">palette.setBrush(backgroundRole(), QBrush(pixmap));</span><br><span class="line">setPalette(palette);</span><br></pre></td></tr></table></figure><p>2.使用Qt捕获windows窗口变化事件函数，自动调整背景缩放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> （当前函数所在类）::resizeEvent(QResizeEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(e);    <span class="comment">//不使用传入参数e，避免警告</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="keyword">this</span>-&gt;widght();    <span class="comment">//w为当前widght宽度</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="keyword">this</span>-&gt;height();    <span class="comment">//h为当前widght高度</span></span><br><span class="line">    QPixmap back_icon(QString::fromUtf8("资源路径"))；    //back_icon指向图片路径</span><br><span class="line">    QPlette.setBrush(<span class="keyword">this</span>-&gt;backgroundRole(),QBrush(back_icon.scaled(w,h)));    <span class="comment">//设置窗体背景和和缩放比例</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;setPalette(palette);    <span class="comment">//设置当前palette生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt设置背景界面&quot;&gt;&lt;a href=&quot;#Qt设置背景界面&quot; class=&quot;headerlink&quot; title=&quot;Qt设置背景界面&quot;&gt;&lt;/a&gt;Qt设置背景界面&lt;/h1&gt;&lt;p&gt;1.设置背景图片的一种方式&lt;/p&gt;
&lt;figure class=&quot;highlight c++
      
    
    </summary>
    
    
      <category term="Qt" scheme="http://yoursite.com/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/09/YY-#pragma%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/10/09/YY-#pragma预处理指令/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:56:50.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pragma预处理指令"><a href="#pragma预处理指令" class="headerlink" title="#pragma预处理指令"></a>#pragma预处理指令</h1><p><strong><em>定义：</em></strong><br>在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。</p><p><strong><em>一般格式：</em></strong></p><p>#pargam Para        其中Para为参数</p><p><strong>举例</strong><br><em>1.message参数：</em><br>    Message 参数能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：</p><p>   #pragma message(“消息文本”)</p><p>   当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。<br>   当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法<br>    #ifdef _X86<br>    #pragma message(“_X86 macro activated!”)<br>    #endif</p><p>当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示“_X86 macro activated! ”。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。</p><p><em>2.code_seg存放代码段：</em></p><p>code_seg对pragma的使用量也比较大</p><p>#pragma code_seg([“section-name”[,”section-class”]])</p><p>它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。</p><p>3.pragma once 执行一次（常用）<br>    只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。<br>    #pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。<br>    #ifndef，#define，#endif这个是C++语言相关，这是C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式</p><p>附件链接：<a href="https://baike.baidu.com/item/%23pragma/706691?fr=aladdin#1_10" target="_blank" rel="noopener">pragma百度百科</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pragma预处理指令&quot;&gt;&lt;a href=&quot;#pragma预处理指令&quot; class=&quot;headerlink&quot; title=&quot;#pragma预处理指令&quot;&gt;&lt;/a&gt;#pragma预处理指令&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;定义：&lt;/em&gt;&lt;/strong&gt;&lt;br
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>阻塞与非阻塞的区别</title>
    <link href="http://yoursite.com/2019/10/09/YY-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/10/09/YY-阻塞与非阻塞的区别/</id>
    <published>2019-10-09T07:11:06.000Z</published>
    <updated>2019-10-09T07:57:02.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h1><p><strong>概念性理解：</strong><br>1.阻塞就是干不完不准回来；<br>2.非阻塞就是你先干，我现在看看有其他事没有，完了告诉我一声。</p><p><strong>以常用函数send和recv举例：</strong><br>    比如你调用send函数发送一定的Byte,在系统内部send做的工作其实只是把数据传输(Copy)到TCP/IP协议栈的输出缓冲区,它执行成功并不代表数据已经成功的发送出去了,如果TCP/IP协议栈没有足够的可用缓冲区来保存你Copy过来的数据的话…这时候就体现出阻塞和非阻塞的不同之处了:对于阻塞模式的socket send函数将不返回直到系统缓冲区有足够的空间把你要发送的数据Copy过去以后才返回,而对于非阻塞的socket来说send会立即返回WSAEWOULDDBLOCK告诉调用者说:”发送操作被阻塞了!!!你想办法处理吧…”<br>    对于recv函数,同样道理,该函数的内部工作机制其实是在等待TCP/IP协议栈的接收缓冲区通知它说:嗨,你的数据来了.对于阻塞模式的socket来说如果TCP/IP协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源….对于非阻塞模式的socket该函数会马上返回,然后告诉你:WSAEWOULDDBLOCK—“现在没有数据,回头在来看看”</p><p><strong>概念性拓展：</strong><br>在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。</p><p><em>同步</em><br>    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p><p><em>异步</em><br>    异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后，socket底 层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供 多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循 环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知 没太多区别。</p><p><em>阻塞</em><br>    阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p><p><em>非阻塞</em><br>    非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阻塞与非阻塞的区别&quot;&gt;&lt;a href=&quot;#阻塞与非阻塞的区别&quot; class=&quot;headerlink&quot; title=&quot;阻塞与非阻塞的区别&quot;&gt;&lt;/a&gt;阻塞与非阻塞的区别&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概念性理解：&lt;/strong&gt;&lt;br&gt;1.阻塞就是干不完不准回来；&lt;
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>两个冒号的作用</title>
    <link href="http://yoursite.com/2019/10/08/C++-%E2%80%9C%EF%BC%9A%EF%BC%9A%E2%80%9D%E4%B8%A4%E4%B8%AA%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/08/C++-“：：”两个冒号的作用/</id>
    <published>2019-10-08T05:28:06.000Z</published>
    <updated>2019-10-09T07:53:25.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“：：”两个冒号的作用"><a href="#“：：”两个冒号的作用" class="headerlink" title="“：：”两个冒号的作用"></a>“：：”两个冒号的作用</h1><p>“::”在C++中表示作用域，和所属关系。”::”是运算符中登记最高的，它分为三种，如下：</p><p>一、作用域符号<br>作用域符号”::”的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。</p><p>例如：A、B表示两个类，在A、B中都有成员member<br>那么：<br>        1、A::member就表示类A中的成员member；<br>        2、B::member就表示类B中的成员member；</p><p>二、全局作用域符号<br>全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，例如：<br>char zhou；    //全局变量<br>void    sleep()<br>{<br>    char zhou;    //局部变量<br>    char(局部变量) = char(局部变量) * char(局部变量);<br>    ::char(全局变量) = ::char(全局变量) * ::char(全局变量)；<br>}</p><p>三、作用域分解运算符<br>::是C++里的作用域分解运算符，比如类说明了一个类A，类A里声明了一个成员函数void f(),但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成void A :: f();表示这个f()函数是类A的成员函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CA&#123;</span><br><span class="line">public :</span><br><span class="line">    int ca_var;</span><br><span class="line">    int add（int a, int b）;</span><br><span class="line">    int add(int a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//那么在实现这个函数时候，必须要这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int CA::add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int CA::add(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return a + :: ca_var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//表示当前类实例中的变量ca_var;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“：：”两个冒号的作用&quot;&gt;&lt;a href=&quot;#“：：”两个冒号的作用&quot; class=&quot;headerlink&quot; title=&quot;“：：”两个冒号的作用&quot;&gt;&lt;/a&gt;“：：”两个冒号的作用&lt;/h1&gt;&lt;p&gt;“::”在C++中表示作用域，和所属关系。”::”是运算符中登记最高
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 标题</title>
    <link href="http://yoursite.com/2019/10/08/Markdown2-%E6%A0%87%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/08/Markdown2-标题/</id>
    <published>2019-10-08T05:28:06.000Z</published>
    <updated>2019-10-14T05:06:53.523Z</updated>
    
    <content type="html"><![CDATA[<p>Mrakdown 标题有两种格式。</p><h1 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用=和 - 标记一级和二级标题"></a>1、使用=和 - 标记一级和二级标题</h1><p>=和-标记语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是一级标题展示</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">这是二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><p>效果如下（在源码格式下查看格式）：</p><h1 id="这是一级标题展示"><a href="#这是一级标题展示" class="headerlink" title="这是一级标题展示"></a>这是一级标题展示</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h1 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用#号标记"></a>2、使用#号标记</h1><p>使用‘#’号可以表一1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>效果如下所示（可以在源码格式下查看详细格式）：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mrakdown 标题有两种格式。&lt;/p&gt;
&lt;h1 id=&quot;1、使用-和-标记一级和二级标题&quot;&gt;&lt;a href=&quot;#1、使用-和-标记一级和二级标题&quot; class=&quot;headerlink&quot; title=&quot;1、使用=和 - 标记一级和二级标题&quot;&gt;&lt;/a&gt;1、使用=和 - 标记
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程实例</title>
    <link href="http://yoursite.com/2019/10/08/Qt-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/10/08/Qt-多线程实例/</id>
    <published>2019-10-08T05:28:06.000Z</published>
    <updated>2019-10-09T07:36:41.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程实例"><a href="#多线程实例" class="headerlink" title="多线程实例"></a>多线程实例</h1><p><strong>使用QThread类，实现Qt多线程</strong></p><p>方法：使用一个类继承QThread，然后重新改写虚函数run()。</p><p><strong>使用moveToThread，实现Qt多线程</strong></p><p>通过这种方法不需要继承QThread,重写run()函数来实现Qt多线程，而是通过moveToThread(QThread *thread)函数将工作累对象移到所创建的QThread对象中去执行。利用信号与槽机制。</p><p>程序结构：<br>1.在主程序中，那里需要多线程就在哪里创建一个QThread实例；<br>2.把耗时操作封装到一个继承QObject的子类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多线程实例&quot;&gt;&lt;a href=&quot;#多线程实例&quot; class=&quot;headerlink&quot; title=&quot;多线程实例&quot;&gt;&lt;/a&gt;多线程实例&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;使用QThread类，实现Qt多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法：使用一个类继承QThre
      
    
    </summary>
    
    
      <category term="YY" scheme="http://yoursite.com/categories/YY/"/>
    
    
      <category term="Qt" scheme="http://yoursite.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Markdown教程</title>
    <link href="http://yoursite.com/2019/10/08/Markdown1-%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/08/Markdown1-使用及语法/</id>
    <published>2019-10-08T04:48:23.000Z</published>
    <updated>2019-10-09T07:58:41.913Z</updated>
    
    <content type="html"><![CDATA[<img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="img" style="zoom: 50%;"><p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown语言在2004年由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。</p><p>Markdown编写的文档后缀名为.md, ,markdown。</p><h1 id="Markdown应用"><a href="#Markdown应用" class="headerlink" title="Markdown应用"></a>Markdown应用</h1><p>Markdown 能被使用来撰写电子书，如：Gitbook。<br>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p><h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>本教程将使用 Typora 编辑器来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。<br>支持导出HTML、PDF、Word、图片等多种类型文件。</p><p>Typora 官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p><p>你也可以使用在线编辑器来测试：<a href="https://c.runoob.com/front-end/712。" target="_blank" rel="noopener">https://c.runoob.com/front-end/712。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png&quot; alt=&quot;img&quot; style=&quot;zoom: 50%;&quot;&gt;

&lt;p&gt;Markdown是一种轻量级
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
