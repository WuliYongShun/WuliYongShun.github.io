<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PicGo+Gitee搭建图床</title>
    <url>/2020/03/21/PicGo%E6%90%AD%E5%BB%BAGitee%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="PicGo搭建Gitee图床"><a href="#PicGo搭建Gitee图床" class="headerlink" title="PicGo搭建Gitee图床"></a>PicGo搭建Gitee图床</h1><h3 id="1、创建Gitee仓库"><a href="#1、创建Gitee仓库" class="headerlink" title="1、创建Gitee仓库"></a>1、创建Gitee仓库</h3><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321212302.png" alt></p>
<h3 id="2、填写仓库信息"><a href="#2、填写仓库信息" class="headerlink" title="2、填写仓库信息"></a>2、填写仓库信息</h3><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321212746.png" alt></p>
<ul>
<li>1、填写仓库名字</li>
<li>2、公开</li>
<li>3、语言随意</li>
<li>4、勾选使用Readme文件初始化这个仓库</li>
<li>5、点击创建</li>
</ul>
<h3 id="3、生成私人令牌"><a href="#3、生成私人令牌" class="headerlink" title="3、生成私人令牌"></a>3、生成私人令牌</h3><h4 id="3-1、点击个人设置"><a href="#3-1、点击个人设置" class="headerlink" title="3.1、点击个人设置"></a>3.1、点击个人设置</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213223.png" alt></p>
<h4 id="3-2、点击私人令牌"><a href="#3-2、点击私人令牌" class="headerlink" title="3.2、点击私人令牌"></a>3.2、点击私人令牌</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213323.png" alt></p>
<h4 id="3-3、生成新令牌"><a href="#3-3、生成新令牌" class="headerlink" title="3.3、生成新令牌"></a>3.3、生成新令牌</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213413.png" alt></p>
<p>随意填写描述提交即可<br><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213601.png" alt></p>
<h4 id="3-4、密码验证"><a href="#3-4、密码验证" class="headerlink" title="3.4、密码验证"></a>3.4、密码验证</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213640.png" alt></p>
<h4 id="3-5、记录个人令牌"><a href="#3-5、记录个人令牌" class="headerlink" title="3.5、记录个人令牌"></a>3.5、记录个人令牌</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321213732.png" alt><br><strong>注意：</strong> <em>只在默认生成的时候出现一次，记得妥善保存</em></p>
<h3 id="4、PicGo配置"><a href="#4、PicGo配置" class="headerlink" title="4、PicGo配置"></a>4、PicGo配置</h3><h4 id="4-1、插件设置，安装gitee插件"><a href="#4-1、插件设置，安装gitee插件" class="headerlink" title="4.1、插件设置，安装gitee插件"></a>4.1、插件设置，安装gitee插件</h4><p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321214009.png" alt></p>
<h4 id="4-2、PicGo图床配置为gitee并设置详细信息"><a href="#4-2、PicGo图床配置为gitee并设置详细信息" class="headerlink" title="4.2、PicGo图床配置为gitee并设置详细信息"></a>4.2、PicGo图床配置为gitee并设置详细信息</h4><p>填写框选中相关信息：</p>
<p><img src="https://gitee.com/wuliyongshun/PictureHouse/raw/master/path/20200321214445.png" alt></p>
<ul>
<li>1、repo填写仓库名：’用户名 + 仓库名’</li>
<li>2、token填写gitee生成的私人令牌</li>
<li>3、其他默认配置，确定并设置为默认图床完成设置。</li>
</ul>
<h3 id="5、特殊问题"><a href="#5、特殊问题" class="headerlink" title="5、特殊问题"></a>5、特殊问题</h3><h4 id="5-1、上传失败原因1"><a href="#5-1、上传失败原因1" class="headerlink" title="5.1、上传失败原因1"></a>5.1、上传失败原因1</h4><p>这个原因一般是库名里有空格或者特殊的符号，一定记住库名允许有空格，如若非要空格才能生效的话，可以通过“-”来代替空格。</p>
<h4 id="5-2其他上传失败原因"><a href="#5-2其他上传失败原因" class="headerlink" title="5.2其他上传失败原因"></a>5.2其他上传失败原因</h4><p>上述设置信息错误，从新检查，因为码云为国内平台，按理说不会出现网络原因导致上传失败的问题。</p>
]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>ADXL361(微功耗三轴加速度计)使用笔记</title>
    <url>/2020/03/14/STM2-ADXL361(%E5%BE%AE%E5%8A%9F%E8%80%97%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1)%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ADXL361-微功耗三轴加速度计-使用笔记"><a href="#ADXL361-微功耗三轴加速度计-使用笔记" class="headerlink" title="ADXL361(微功耗三轴加速度计)使用笔记"></a>ADXL361(微功耗三轴加速度计)使用笔记</h1><h3 id="一、硬件介绍"><a href="#一、硬件介绍" class="headerlink" title="一、硬件介绍"></a>一、硬件介绍</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h4><p>超低功耗<br><strong>待机电流:</strong> 10nA<br><strong>运动唤醒模式电流:</strong> 270nA<br><strong>高分辨率:</strong> 1 mg/LSB<br><strong>数字接口:</strong> SPI数字接口<br><strong>供电电压:</strong> 1.6 V至3.5 V</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ADXL362是一款超低功耗、 3轴MEMS加速度计，输出数据速率为100 Hz时功耗低于2 μA，在运动触发唤醒模式下功耗为270 nA。与使用周期采样来实现低功耗的加速度计不同，ADXL362没有通过欠采样混叠输入信号；它采用全数据速率对传感器的整个带宽进行采样。ADXL362通常提供12位输出分辨率；在较低分辨率足够时，还提供8位数据输出以实现更高效的单字节传送。测量范围为±2 g、 ±4 g及±8 g， ±2 g范围内的分辨率为1 mg/LSB。噪声电平要求低于ADXL362正常值550 μg/√Hz的应用可以选择两个低噪声模式(典型值低至175 μg/√Hz)之一，电源电流增加极小。除了超低功耗以外， ADXL362还具有许多特性来实现真正的系统级节能。该器件包含了一个深度多模式输出FIFO、一个内置微功耗温度传感器和几个运动检测模式，其中包括阙值可调的睡眠和唤醒工作模式，在该模式下当测量速率为6 HZ左右时功耗低至270 nA。如有需要，可在检测到运动时提供一个引脚输出来直接控制外部开关。此外，ADXL362还支持对采样时间和/或系统时钟进行外部控制。ADXL362可以在1.6V至3.5V的宽电源电压范围内工作，并且必要时可以与采用独立低电源电压工作的主机接口。</p>
<h4 id="引脚配置和功能描述"><a href="#引脚配置和功能描述" class="headerlink" title="引脚配置和功能描述"></a>引脚配置和功能描述</h4><p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200313173608.png" alt></p>
<p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200313173627.png" alt></p>
<h3 id="二、驱动程序"><a href="#二、驱动程序" class="headerlink" title="二、驱动程序"></a>二、驱动程序</h3><p>驱动程序调试成功，正常通讯，使用STM32单片机（Hal库）形式对传感器进行控制操作及读取数据，源码如下（程序原理ADI官方代码，修改其中读写程序即可），经过测试驱动程序正常使用。</p>
<h4 id="1、头文件"><a href="#1、头文件" class="headerlink" title="1、头文件"></a>1、头文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  *               Copyright(C) 2016-2026 GDKY All Rights Reserved</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @file     ADXL362Driver.c</span></span><br><span class="line"><span class="comment">  * @author   YSHUN</span></span><br><span class="line"><span class="comment">  * @version  V1.00</span></span><br><span class="line"><span class="comment">  * @date     2020.02.05</span></span><br><span class="line"><span class="comment">  * @brief    硬件层驱动处理程序.</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADXL362_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADXL362_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INCLUDES ------------------------------------------------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32l0xx_hal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gpio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"spi.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* TYPEDEFS ------------------------------------------------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_CS_Pin GPIO_PIN_1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_CS_GPIO_Port GPIOB</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clr_Cs()	HAL_GPIO_WritePin(ADXL362_CS_GPIO_Port, ADXL362_CS_Pin, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Set_Cs()	HAL_GPIO_WritePin(ADXL362_CS_GPIO_Port, ADXL362_CS_Pin, GPIO_PIN_SET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_SLAVE_ID    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362 communication commands */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_WRITE_REG           0x0A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_READ_REG            0x0B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_WRITE_FIFO          0x0D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_DEVID_AD            0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_DEVID_MST           0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_PARTID              0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_REVID               0x03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_XDATA               0x08	<span class="comment">//X轴数据(8 MSB)寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_YDATA               0x09	<span class="comment">//Y轴数据(8 MSB)寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_ZDATA               0x0A	<span class="comment">//Z轴数据(8 MSB)寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_STATUS              0x0B	<span class="comment">//状态寄存器，用于指示ADXL362的各种状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_FIFO_L              0x0C	<span class="comment">//FIFO条目寄存器,低8位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_FIFO_H              0x0D	<span class="comment">//FIFO条目寄存器,高8位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_XDATA_L             0x0E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_XDATA_H             0x0F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_YDATA_L             0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_YDATA_H             0x11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_ZDATA_L             0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_ZDATA_H             0x13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_TEMP_L              0x14	<span class="comment">//温度数据寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_TEMP_H              0x15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_SOFT_RESET          0x1F	<span class="comment">//软复位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_THRESH_ACT_L        0x20	<span class="comment">//运动阈值寄存器，保存8个LSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_THRESH_ACT_H        0x21	<span class="comment">//运动阈值寄存器，保存3个MSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_TIME_ACT            0x22	<span class="comment">//运动时间寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_THRESH_INACT_L      0x23	<span class="comment">//静止阈值寄存器，保存8个LSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_THRESH_INACT_H      0x24	<span class="comment">//静止阈值寄存器，保存3个MSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_TIME_INACT_L        0x25	<span class="comment">//静止时间寄存器，保存8个LSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_TIME_INACT_H        0x26	<span class="comment">//静止时间寄存器，保存8个MSB</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_ACT_INACT_CTL       0x27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_FIFO_CTL            0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_FIFO_SAMPLES        0x29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_INTMAP1             0x2A	<span class="comment">//INT1/INT2功能映射寄存器,INT1映射</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_INTMAP2             0x2B	<span class="comment">//INT1/INT2功能映射寄存器,INT2映射</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_FILTER_CTL          0x2C	<span class="comment">//滤波器控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_POWER_CTL           0x2D	<span class="comment">//电源控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_REG_SELF_TEST           0x2E	<span class="comment">//自检寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_STATUS definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_ERR_USER_REGS        (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_AWAKE                (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_INACT                (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_ACT                  (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_FIFO_OVERRUN         (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_FIFO_WATERMARK       (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_FIFO_RDY             (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_STATUS_DATA_RDY             (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_ACT_INACT_CTL definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ACT_INACT_CTL_LINKLOOP(x)   (((x) &amp; 0x3) &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ACT_INACT_CTL_INACT_REF     (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ACT_INACT_CTL_INACT_EN      (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ACT_INACT_CTL_ACT_REF       (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ACT_INACT_CTL_ACT_EN        (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_ACT_INACT_CTL_LINKLOOP(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_MODE_DEFAULT        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_MODE_LINK           1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_MODE_LOOP           3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_FIFO_CTL */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_CTL_AH                 (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_CTL_FIFO_TEMP          (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_CTL_FIFO_MODE(x)       (((x) &amp; 0x3) &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_FIFO_CTL_FIFO_MODE(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_DISABLE              0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_OLDEST_SAVED         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_STREAM               2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FIFO_TRIGGERED            3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_INTMAP1 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_INT_LOW             (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_AWAKE               (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_INACT               (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_ACT                 (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_FIFO_OVERRUN        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_FIFO_WATERMARK      (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_FIFO_READY          (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP1_DATA_READY          (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_INTMAP2 definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_INT_LOW             (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_AWAKE               (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_INACT               (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_ACT                 (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_FIFO_OVERRUN        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_FIFO_WATERMARK      (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_FIFO_READY          (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_INTMAP2_DATA_READY          (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_FILTER_CTL definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FILTER_CTL_RANGE(x)         (((x) &amp; 0x3) &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FILTER_CTL_RES              (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FILTER_CTL_HALF_BW          (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FILTER_CTL_EXT_SAMPLE       (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_FILTER_CTL_ODR(x)           (((x) &amp; 0x7) &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_FILTER_CTL_RANGE(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_RANGE_2G                0 <span class="comment">/* +-2 g */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_RANGE_4G                1 <span class="comment">/* +-4 g */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_RANGE_8G                2 <span class="comment">/* +-8 g */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_FILTER_CTL_ODR(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_12_5_HZ             0 <span class="comment">/* 12.5 Hz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_25_HZ               1 <span class="comment">/* 25 Hz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_50_HZ               2 <span class="comment">/* 50 Hz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_100_HZ              3 <span class="comment">/* 100 Hz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_200_HZ              4 <span class="comment">/* 200 Hz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_ODR_400_HZ              5 <span class="comment">/* 400 Hz */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_POWER_CTL definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_RES               (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_EXT_CLK           (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_LOW_NOISE(x)      (((x) &amp; 0x3) &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_WAKEUP            (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_AUTOSLEEP         (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_POWER_CTL_MEASURE(x)        (((x) &amp; 0x3) &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_POWER_CTL_LOW_NOISE(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_NOISE_MODE_NORMAL           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_NOISE_MODE_LOW              1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_NOISE_MODE_ULTRALOW         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_POWER_CTL_MEASURE(x) options */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_MEASURE_STANDBY         0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_MEASURE_ON              2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362_REG_SELF_TEST */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_SELF_TEST_ST            (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362 device information */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_DEVICE_AD               0xAD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_DEVICE_MST              0x1D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_PART_ID                 0xF2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADXL362 Reset settings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADXL362_RESET_KEY               0x52</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MACROS  -------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CONSTANTS  ----------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GLOBAL VARIABLES ----------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GLOBAL FUNCTIONS ----------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Initializes the device. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">ADXL362_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Writes data into a register. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetRegisterValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> registerValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  registerAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  bytesNumber)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Performs a burst read of a specified number of registers. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetRegisterValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pReadData,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  registerAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  bytesNumber)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Reads multiple bytes from the device's FIFO buffer. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetFifoValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> bytesNumber)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Resets the device via SPI communication bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SoftwareReset</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Places the device into standby/measure mode. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetPowerMode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> pwrMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Selects the measurement range. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> gRange)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Selects the Output Data Rate of the device. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetOutputRate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> outRate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Reads the 3-axis raw data from the accelerometer. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetXyz</span><span class="params">(<span class="keyword">short</span> *x, <span class="keyword">short</span> *y, <span class="keyword">short</span> *z)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Reads the temperature of the device. */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADXL362_ReadTemperature</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Configures the FIFO feature. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_FifoSetup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">short</span> waterMarkLvl,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">char</span>  enTempRead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Configures activity detection. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetupActivityDetection</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  refOrAbs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">unsigned</span> <span class="keyword">short</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">unsigned</span> <span class="keyword">char</span>  time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! Configures inactivity detection. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetupInactivityDetection</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  refOrAbs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">short</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">short</span> time)</span></span>;</span><br><span class="line">																			</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_Set</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 芯片ID读取 */</span>																			</span><br><span class="line"><span class="keyword">uint16_t</span>	ADXL362_ReadID(<span class="keyword">void</span>);</span><br><span class="line">																			</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetData</span><span class="params">(<span class="keyword">int16_t</span> *Xdata,<span class="keyword">int16_t</span> *Ydata,<span class="keyword">int16_t</span> *Zdata,<span class="keyword">int16_t</span> *Tdata)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒模式初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_WakeUpMode</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">																			</span><br><span class="line">																			</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* __ADXL362_H__ */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1、源码文件"><a href="#1、源码文件" class="headerlink" title="1、源码文件"></a>1、源码文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  *               Copyright(C) 2016-2026 GDKY All Rights Reserved</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @file     ADXL362Driver.c</span></span><br><span class="line"><span class="comment">  * @author   YSHUN</span></span><br><span class="line"><span class="comment">  * @version  V1.00</span></span><br><span class="line"><span class="comment">  * @date     2020.02.05</span></span><br><span class="line"><span class="comment">  * @brief    硬件层驱动处理程序.</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INCLUDES ------------------------------------------------------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ADXL362.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  唤醒模式初始化</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_WakeUpMode</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 1、写入十进制250 (0xFA)到寄存器0x20，写入0到寄存器0x21：将运动阈值设为250 mg */</span></span><br><span class="line"><span class="comment">//	ADXL362_SetRegisterValue( 0xFA, 0x20, 1 );</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x32</span>, <span class="number">0x20</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、写入十进制150 (0x96)到寄存器0x23，写入0到寄存器0x24：将静止阈值设为150 mg */</span></span><br><span class="line"><span class="comment">//	ADXL362_SetRegisterValue( 0x96, 0x23, 1 );</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x32</span>, <span class="number">0x20</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、写入十进制30 (0x1E)到寄存器0x25：将静止定时器设为30个样本或约5秒 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x1E</span>, <span class="number">0x25</span>, <span class="number">1</span> );</span><br><span class="line"><span class="comment">//	ADXL362_SetRegisterValue( 0x10, 0x25, 1 );</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、写入0x3F到寄存器0x27：配置环路模式的运动检测并使能相对运动和静止检测 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x3F</span>, <span class="number">0x27</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、写入0x40到寄存器0x2B：将AWAKE位映射到INT2。INT2引脚与开关的栅极相连 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x40</span>, <span class="number">0x2B</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、写入0x0A到寄存器0x2D：开始在唤醒模式下进行测量*/</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x0A</span>, <span class="number">0x2D</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  唤醒模式初始化</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL632_WakeMode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 设置设备为待机模式,先进入待机模式配置将不会影响到传感器数据 */</span></span><br><span class="line">	ADXL362_SetPowerMode(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 加速计的输出数据速率设置为: 12.5 Hz. */</span></span><br><span class="line">	ADXL362_SetOutputRate(ADXL362_ODR_12_5_HZ);</span><br><span class="line">	<span class="comment">/* 测量范围设置为4g */</span></span><br><span class="line">	ADXL362_SetRange(ADXL362_RANGE_4G);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 失能中断输出 */</span></span><br><span class="line">	ADXL362_SetRegisterValue(ADXL362_REG_INTMAP1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	ADXL362_SetRegisterValue(ADXL362_REG_INTMAP2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 运动/静止控制寄存器配置,配置为环路模式内部中断信号 */</span></span><br><span class="line">	ADXL362_SetRegisterValue(ADXL362_ACT_INACT_CTL_LINKLOOP(ADXL362_MODE_LOOP) \</span><br><span class="line">													| ADXL362_ACT_INACT_CTL_INACT_EN \</span><br><span class="line">												 	| ADXL362_ACT_INACT_CTL_ACT_EN , </span><br><span class="line">													ADXL362_REG_ACT_INACT_CTL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置运动状态阈值 */</span></span><br><span class="line">	ADXL362_SetupActivityDetection(<span class="number">1</span>, <span class="number">30</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置静止状态阈值 */</span></span><br><span class="line">	ADXL362_SetupInactivityDetection(<span class="number">1</span>, <span class="number">700</span>, <span class="number">25</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* FIFO缓冲区设置 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 输出中断使能，设置INT1为运动中断  INT2为唤醒中断*/</span></span><br><span class="line">	ADXL362_SetRegisterValue(ADXL362_INTMAP1_ACT, ADXL362_REG_INTMAP1, <span class="number">1</span>);</span><br><span class="line">	ADXL362_SetRegisterValue(ADXL362_INTMAP2_INACT, ADXL362_REG_INTMAP2, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 进入测量模式，开始测量过程 */</span></span><br><span class="line">	ADXL362_SetPowerMode(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//	ADXL362_SetRegisterValue(0xC0, ADXL362_REG_POWER_CTL, 1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  初始化与设备的通信，并通过读取设备id检查部件是否存在</span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval 1 成功</span></span><br><span class="line"><span class="comment">	*					0 失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">ADXL362_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> regValue = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> status   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SPI Init */</span></span><br><span class="line"><span class="comment">//	MX_SPI1_Init();</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	ADXL362_SoftwareReset();</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	ADXL362_GetRegisterValue(&amp;regValue, ADXL362_REG_PARTID, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>((regValue != ADXL362_PART_ID))</span><br><span class="line">	&#123;</span><br><span class="line">		status = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		status = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ADXL362_WakeUpMode( );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  写数据到寄存器</span></span><br><span class="line"><span class="comment">  * @param  registerValue - 写数据值</span></span><br><span class="line"><span class="comment">  * @param  registerAddress - 寄存器地址</span></span><br><span class="line"><span class="comment">  * @param  bytesNumber - 字节数. Accepted values: 0 - 1</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetRegisterValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> registerValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  registerAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  bytesNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">		<span class="keyword">uint8_t</span> m_reg_cmd = <span class="number">0</span>;</span><br><span class="line">		m_reg_cmd = ADXL362_WRITE_REG;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(registerAddress &gt; ADXL362_REG_SELF_TEST)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Clr_Cs();</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;m_reg_cmd, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;registerAddress, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;registerValue, bytesNumber, <span class="number">1000</span>);</span><br><span class="line">		Set_Cs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  读数据从寄存器</span></span><br><span class="line"><span class="comment">  * @param  pReadData - 读缓冲区</span></span><br><span class="line"><span class="comment">  * @param  registerAddress - 寄存器地址</span></span><br><span class="line"><span class="comment">  * @param  bytesNumber - 字节数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetRegisterValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* pReadData,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  registerAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">unsigned</span> <span class="keyword">char</span>  bytesNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">		<span class="keyword">uint8_t</span> m_reg_addr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">uint8_t</span> m_reg_cmd = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		m_reg_addr = registerAddress;</span><br><span class="line">		m_reg_cmd = ADXL362_READ_REG;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(pReadData == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m_reg_cmd &gt; ADXL362_REG_SELF_TEST)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Clr_Cs();</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;m_reg_cmd, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;m_reg_addr, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		HAL_SPI_Receive(&amp;hspi1, pReadData, bytesNumber, <span class="number">1000</span>);</span><br><span class="line">		Set_Cs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  从设备的FIFO缓冲区读取多个字节</span></span><br><span class="line"><span class="comment">  * @param  pBuffer - 存储读取字节缓冲区</span></span><br><span class="line"><span class="comment">  * @param  bytesNumber - 字节数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetFifoValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* pBuffer, <span class="keyword">unsigned</span> <span class="keyword">short</span> bytesNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> m_reg_cmd = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		m_reg_cmd = ADXL362_WRITE_FIFO;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Clr_Cs();</span><br><span class="line">		HAL_SPI_Transmit(&amp;hspi1, &amp;m_reg_cmd, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		HAL_SPI_Receive(&amp;hspi1, pBuffer, bytesNumber, <span class="number">1000</span>);</span><br><span class="line">		Set_Cs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  软复位</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SoftwareReset</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ADXL362_SetRegisterValue(ADXL362_RESET_KEY, ADXL362_REG_SOFT_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  芯片ID读取</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @retval 设备ID(默认为0xAD)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">uint16_t</span> ADXL362_ReadID(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> defID = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 读取器件ID，默认0xAD */</span></span><br><span class="line">	ADXL362_GetRegisterValue(&amp;defID, ADXL362_REG_DEVID_AD, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> defID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  将设备置于待机/测量模式</span></span><br><span class="line"><span class="comment">  * @param pwrMode - Power mode.</span></span><br><span class="line"><span class="comment">  *                  Example: 0 - standby mode.</span></span><br><span class="line"><span class="comment">  *		                     1 - measure mode.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetPowerMode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> pwrMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oldPowerCtl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> newPowerCtl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ADXL362_GetRegisterValue(&amp;oldPowerCtl, ADXL362_REG_POWER_CTL, <span class="number">1</span>);</span><br><span class="line">    newPowerCtl = oldPowerCtl &amp; ~ADXL362_POWER_CTL_MEASURE(<span class="number">0x3</span>);</span><br><span class="line">    newPowerCtl = newPowerCtl |</span><br><span class="line">                  (pwrMode * ADXL362_POWER_CTL_MEASURE(ADXL362_MEASURE_ON));</span><br><span class="line">    ADXL362_SetRegisterValue(newPowerCtl, ADXL362_REG_POWER_CTL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  测量范围选择</span></span><br><span class="line"><span class="comment">  * @param gRange - Range option.</span></span><br><span class="line"><span class="comment">  *                  Example: ADXL362_RANGE_2G  -  +-2 g</span></span><br><span class="line"><span class="comment">  *                           ADXL362_RANGE_4G  -  +-4 g</span></span><br><span class="line"><span class="comment">  *                           ADXL362_RANGE_8G  -  +-8 g</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> gRange)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oldFilterCtl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> newFilterCtl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ADXL362_GetRegisterValue(&amp;oldFilterCtl, ADXL362_REG_FILTER_CTL, <span class="number">1</span>);</span><br><span class="line">    newFilterCtl = oldFilterCtl &amp; ~ADXL362_FILTER_CTL_RANGE(<span class="number">0x3</span>);</span><br><span class="line">    newFilterCtl = newFilterCtl | ADXL362_FILTER_CTL_RANGE(gRange);</span><br><span class="line">    ADXL362_SetRegisterValue(newFilterCtl, ADXL362_REG_FILTER_CTL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  选择设备的输出数据速率</span></span><br><span class="line"><span class="comment">  * @param outRate - Output Data Rate option.</span></span><br><span class="line"><span class="comment">  *                  Example: ADXL362_ODR_12_5_HZ  -  12.5Hz</span></span><br><span class="line"><span class="comment">  *                           ADXL362_ODR_25_HZ    -  25Hz</span></span><br><span class="line"><span class="comment">  *                           ADXL362_ODR_50_HZ    -  50Hz</span></span><br><span class="line"><span class="comment">  *                           ADXL362_ODR_100_HZ   -  100Hz</span></span><br><span class="line"><span class="comment">  *                           ADXL362_ODR_200_HZ   -  200Hz</span></span><br><span class="line"><span class="comment">  *                           ADXL362_ODR_400_HZ   -  400Hz</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetOutputRate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> outRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oldFilterCtl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> newFilterCtl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ADXL362_GetRegisterValue(&amp;oldFilterCtl, ADXL362_REG_FILTER_CTL, <span class="number">1</span>);</span><br><span class="line">    newFilterCtl = oldFilterCtl &amp; ~ADXL362_FILTER_CTL_ODR(<span class="number">0x7</span>);</span><br><span class="line">    newFilterCtl = newFilterCtl | ADXL362_FILTER_CTL_ODR(outRate);</span><br><span class="line">    ADXL362_SetRegisterValue(newFilterCtl, ADXL362_REG_FILTER_CTL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  从加速度计读取3轴原始数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param x - Stores the X-axis data(as two's complement).</span></span><br><span class="line"><span class="comment">  * @param y - Stores the X-axis data(as two's complement).</span></span><br><span class="line"><span class="comment">  * @param z - Stores the X-axis data(as two's complement).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_GetXyz</span><span class="params">(<span class="keyword">short</span>* x, <span class="keyword">short</span>* y, <span class="keyword">short</span>* z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> xyzValues[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ADXL362_GetRegisterValue(xyzValues, ADXL362_REG_XDATA_L, <span class="number">6</span>);</span><br><span class="line">    *x = ((<span class="keyword">short</span>)xyzValues[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + xyzValues[<span class="number">0</span>];</span><br><span class="line">    *y = ((<span class="keyword">short</span>)xyzValues[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) + xyzValues[<span class="number">2</span>];</span><br><span class="line">    *z = ((<span class="keyword">short</span>)xyzValues[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) + xyzValues[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  读设备温度</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @retval tempCelsius - 温度（摄氏度）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ADXL362_ReadTemperature</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> rawTempData[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">short</span>         signedTemp     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span>         tempCelsius    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ADXL362_GetRegisterValue(rawTempData, ADXL362_REG_TEMP_L, <span class="number">2</span>);</span><br><span class="line">    signedTemp = (<span class="keyword">short</span>)(rawTempData[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + rawTempData[<span class="number">0</span>];</span><br><span class="line">    tempCelsius = (<span class="keyword">float</span>)signedTemp * <span class="number">0.065</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tempCelsius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  配置FIFO特征</span></span><br><span class="line"><span class="comment">  * @param mode - 可选择模式</span></span><br><span class="line"><span class="comment">  *               Example: ADXL362_FIFO_DISABLE        -  FIFO 失能.</span></span><br><span class="line"><span class="comment">  *                        ADXL362_FIFO_OLDEST_SAVED   -  Oldest saved mode.</span></span><br><span class="line"><span class="comment">  *                        ADXL362_FIFO_STREAM         -  Stream mode.</span></span><br><span class="line"><span class="comment">  *                        ADXL362_FIFO_TRIGGERED      -  Triggered mode.</span></span><br><span class="line"><span class="comment">  * @param waterMarkLvl - 指定要存储在FIFO中的样本数.</span></span><br><span class="line"><span class="comment">  * @param enTempRead - 将温度数据存储到FIFO</span></span><br><span class="line"><span class="comment">  *                     Example: 1 - temperature data is stored in the FIFO</span></span><br><span class="line"><span class="comment">  *                                  together with x-, y- and x-axis data.</span></span><br><span class="line"><span class="comment">  *                              0 - temperature data is skipped.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_FifoSetup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">short</span> waterMarkLvl,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">char</span>  enTempRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> writeVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    writeVal = ADXL362_FIFO_CTL_FIFO_MODE(mode) |</span><br><span class="line">               (enTempRead * ADXL362_FIFO_CTL_FIFO_TEMP) |</span><br><span class="line">               ADXL362_FIFO_CTL_AH;</span><br><span class="line">    ADXL362_SetRegisterValue(writeVal, ADXL362_REG_FIFO_CTL, <span class="number">1</span>);</span><br><span class="line">    ADXL362_SetRegisterValue(waterMarkLvl, ADXL362_REG_FIFO_SAMPLES, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  配置活动检测</span></span><br><span class="line"><span class="comment">  * @param  refOrAbs - 参考/绝对 活动选择</span></span><br><span class="line"><span class="comment">  *                   Example: 0 - absolute mode.</span></span><br><span class="line"><span class="comment">  *                            1 - referenced mode.</span></span><br><span class="line"><span class="comment">  * @param  threshold - 11-bit unsigned value that the adxl362 samples are</span></span><br><span class="line"><span class="comment">  *                    compared to.</span></span><br><span class="line"><span class="comment">  * @param  time - 8-bit value written to the activity timer register. The amount</span></span><br><span class="line"><span class="comment">  *               of time (in seconds) is: time / ODR, where ODR - is the output </span></span><br><span class="line"><span class="comment">  *               data rate.</span></span><br><span class="line"><span class="comment">  * @retval None.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetupActivityDetection</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  refOrAbs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">unsigned</span> <span class="keyword">short</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">unsigned</span> <span class="keyword">char</span>  time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oldActInactReg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> newActInactReg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure motion threshold and activity timer. */</span></span><br><span class="line">    ADXL362_SetRegisterValue((threshold &amp; <span class="number">0x7FF</span>), ADXL362_REG_THRESH_ACT_L, <span class="number">2</span>);</span><br><span class="line">    ADXL362_SetRegisterValue(time, ADXL362_REG_TIME_ACT, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Enable activity interrupt and select a referenced or absolute</span></span><br><span class="line"><span class="comment">       configuration. */</span></span><br><span class="line">    ADXL362_GetRegisterValue(&amp;oldActInactReg, ADXL362_REG_ACT_INACT_CTL, <span class="number">1</span>);</span><br><span class="line">    newActInactReg = oldActInactReg &amp; ~ADXL362_ACT_INACT_CTL_ACT_REF;</span><br><span class="line">    newActInactReg |= ADXL362_ACT_INACT_CTL_ACT_EN |</span><br><span class="line">                     (refOrAbs * ADXL362_ACT_INACT_CTL_ACT_REF);</span><br><span class="line">    ADXL362_SetRegisterValue(newActInactReg, ADXL362_REG_ACT_INACT_CTL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  配置不活动检测</span></span><br><span class="line"><span class="comment">  * @param refOrAbs - 参考/绝对不活动选择</span></span><br><span class="line"><span class="comment">  *                   Example: 0 - absolute mode.</span></span><br><span class="line"><span class="comment">  *                            1 - referenced mode.</span></span><br><span class="line"><span class="comment">  * @param threshold - 11-bit unsigned value that the adxl362 samples are</span></span><br><span class="line"><span class="comment">  *                    compared to.</span></span><br><span class="line"><span class="comment">  * @param time - 16-bit value written to the inactivity timer register. The </span></span><br><span class="line"><span class="comment">  *               amount of time (in seconds) is: time / ODR, where ODR - is the </span></span><br><span class="line"><span class="comment">  *               output  data rate.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_SetupInactivityDetection</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>  refOrAbs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">short</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">unsigned</span> <span class="keyword">short</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oldActInactReg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> newActInactReg = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Configure motion threshold and inactivity timer. */</span></span><br><span class="line">    ADXL362_SetRegisterValue((threshold &amp; <span class="number">0x7FF</span>),</span><br><span class="line">                              ADXL362_REG_THRESH_INACT_L,</span><br><span class="line">                              <span class="number">2</span>);</span><br><span class="line">    ADXL362_SetRegisterValue(time, ADXL362_REG_TIME_INACT_L, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* Enable inactivity interrupt and select a referenced or absolute</span></span><br><span class="line"><span class="comment">       configuration. */</span></span><br><span class="line">    ADXL362_GetRegisterValue(&amp;oldActInactReg, ADXL362_REG_ACT_INACT_CTL, <span class="number">1</span>);</span><br><span class="line">    newActInactReg = oldActInactReg &amp; ~ADXL362_ACT_INACT_CTL_INACT_REF;</span><br><span class="line">    newActInactReg |= ADXL362_ACT_INACT_CTL_INACT_EN |</span><br><span class="line">                     (refOrAbs * ADXL362_ACT_INACT_CTL_INACT_REF);</span><br><span class="line">    ADXL362_SetRegisterValue(newActInactReg, ADXL362_REG_ACT_INACT_CTL, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、芯片使用"><a href="#二、芯片使用" class="headerlink" title="二、芯片使用"></a>二、芯片使用</h3><p>使用芯片的运动唤醒模式功能，通过映射唤醒信号到中断INT2引脚，控制单片机发送数据。</p>
<h3 id="1、运动唤醒模式"><a href="#1、运动唤醒模式" class="headerlink" title="1、运动唤醒模式"></a>1、运动唤醒模式</h3><p>唤醒模式非常适合进行简单的有无运动检测，其功耗极低(2.0 V电源电压时仅270 nA)。唤醒模式对于实现运动激活的开关操作特别有用，系统其余部分只有在检测到运动之后才激活。<br>唤醒模式仅以大约每秒6次的频率测量加速度以确定是否发生运动，从而将功耗降至非常低的水平。如果检测到运动，加速度计可以通过如下方式自治响应：</p>
<ul>
<li>切换到全带宽测量模式</li>
<li>向微控制器发出一个中断信号</li>
<li>唤醒下游电路，具体依配置而定</li>
</ul>
<p>在唤醒模式下，除运动定时器以外的所有其它加速计功能都可以使用。所有寄存器都可以访问，实时数据可以读出和/或存入FIFO。</p>
<h4 id="1-1唤醒模式的体现由AWAKE位来体现"><a href="#1-1唤醒模式的体现由AWAKE位来体现" class="headerlink" title="1.1唤醒模式的体现由AWAKE位来体现"></a>1.1唤醒模式的体现由AWAKE位来体现</h4><p>AWAKE位用于指示ADXL362处于唤醒还是休眠状态。当器件运动时，器件唤醒；当器件静止时，器件休眠。<br>唤醒信号可以映射到INT1或INT2引脚，该引脚可以用作状态输出，用以根据加速度计的唤醒状态，连接或断开下游电路的电源。配合环路模式时，此配置可实现自治运动激活的开关，如图所示。<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200313172247.png" alt><br>如果下游电路的开启时间是可接受的，此运动开关配置可以消除应用其余部分的待机功耗，从而大幅降低系统级功耗。此待机功耗常常超过ADXL362的正常工作功耗。</p>
<h4 id="1-2自治运动开关原理及程序"><a href="#1-2自治运动开关原理及程序" class="headerlink" title="1.2自治运动开关原理及程序"></a>1.2自治运动开关原理及程序</h4><p>ADXL362的特性使它非常适合用作自治运动开关。下面的示例实现了一个开关，配置好后，它不需要主机处理器的干预，就能灵巧地管理系统电源。本例中，唤醒信号映射到INT2引脚，<del>用以驱动高边功率开关(如ADP195等)来控制下游电路的电源</del>,我们这里用中断信号唤醒单片机并，通过485向另一块电路板发送数据。</p>
<p><strong>程序启动流程</strong><br><em>假设使用±2 g测量范围和唤醒工作模式</em></p>
<ul>
<li>1、写入十进制250 (0xFA)到寄存器0x20，写入0到寄存器0x21：将运动阈值设为250 mg。</li>
<li>2、写入十进制150 (0x96)到寄存器0x23，写入0到寄存器0x24：将静止阈值设为150 mg。</li>
<li>3、写入十进制30 (0x1E)到寄存器0x25：将静止定时器设为30个样本或约5秒。</li>
<li>4、写入0x3F到寄存器0x27：配置环路模式的运动检测并使能相对运动和静止检测。</li>
<li>5、写入0x40到寄存器0x2B：将AWAKE位映射到INT2。INT2引脚与开关的栅极相连。</li>
<li>6、写入0x0A到寄存器0x2D：开始在唤醒模式下进行测量。</li>
</ul>
<p>对应相关程序代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADXL362_WakeUpMode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 1、写入十进制250 (0xFA)到寄存器0x20，写入0到寄存器0x21：将运动阈值设为250 mg。 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0xFA</span>, <span class="number">0x20</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、写入十进制150 (0x96)到寄存器0x23，写入0到寄存器0x24：将静止阈值设为150 mg。 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x96</span>, <span class="number">0x23</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、写入十进制30 (0x1E)到寄存器0x25：将静止定时器设为30个样本或约5秒。 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x1E</span>, <span class="number">0x25</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 4、写入0x3F到寄存器0x27：配置环路模式的运动检测并使能相对运动和静止检测。 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x3F</span>, <span class="number">0x27</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5、写入0x40到寄存器0x2B：将AWAKE位映射到INT2。INT2引脚与开关的栅极相连。 */</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x40</span>, <span class="number">0x2B</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 6、写入0x0A到寄存器0x2D：开始在唤醒模式下进行测量。*/</span></span><br><span class="line">	ADXL362_SetRegisterValue( <span class="number">0x0A</span>, <span class="number">0x2D</span>, <span class="number">1</span> );</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进过验证传感器正常，唤醒功能正常</strong>同时该传感器作为动作开关可以根据’ 0x20,和0x23 ‘设置动作阈值,来改变传感器的灵敏度。<br><em>需要注意的是，需要按照参考手册的时序进行操作</em></p>
<h3 id="2、静止检测模式"><a href="#2、静止检测模式" class="headerlink" title="2、静止检测模式"></a>2、静止检测模式</h3><p>后续更新</p>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo+Github搭建图床</title>
    <url>/2020/03/14/PicGo%E6%90%AD%E5%BB%BAGithub%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="PicGo-Github搭建图床"><a href="#PicGo-Github搭建图床" class="headerlink" title="PicGo+Github搭建图床"></a>PicGo+Github搭建图床</h1><h3 id="1、为什么要用PicGo"><a href="#1、为什么要用PicGo" class="headerlink" title="1、为什么要用PicGo"></a>1、为什么要用PicGo</h3><p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314171534.png" alt></p>
<p>为了记录笔记以及编写文档，使用了各种MarkDown软件，<code>Typora</code>,<code>有道云笔记</code>,<code>Vnote</code>啊这些，除了云笔记以外其他得基于Markdown语法的软件都只能保存本地图片链接和网络图片链接，当我换一台电脑或者网络图片的链接挂掉以后，问题就出现了，我的图片都没了，时间久了问题多了，文档和笔记都乱了。为了解决这个问题，我找到了PicGo+GitHub图床的方法，制作个人图床，这样的话以上的问题都迎刃而解了，除非github挂掉，否则我的图片就不会有问题。<br>我们的思路就是使用PicGo将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪。</p>
<h3 id="2、PicGo简介"><a href="#2、PicGo简介" class="headerlink" title="2、PicGo简介"></a>2、PicGo简介</h3><p>这是一款图片上传的工具，目前支持微博图床，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。<br>同时PicGo是一个免费开源的软件，其GitHub地址为：<code>https://github.com/WuliYongShun/PicGo.git</code><br>可以选择相关releases版本进行下载和安装，或者直接下载源码编译使用。<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314171501.png" alt></p>
<h3 id="3、准备工作"><a href="#3、准备工作" class="headerlink" title="3、准备工作"></a>3、准备工作</h3><p>主要是两个方面工作，一方面是使用github创建仓库并生成并保存taken，两仪方面的工作是根据github仓库芯片对PicGo软件进行相关配置工作</p>
<h4 id="3-1、GitHub相关工作"><a href="#3-1、GitHub相关工作" class="headerlink" title="3.1、GitHub相关工作"></a>3.1、GitHub相关工作</h4><ul>
<li>1、创建仓库</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314165902.png" alt></p>
<p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170016.png" alt></p>
<ul>
<li>2、生成并保存Token</li>
</ul>
<p>点击settings：<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170319.png" alt></p>
<p>点击Developer settings<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170421.png" alt></p>
<p>点击Personal access tokens<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170529.png" alt></p>
<p>点击Generate new token<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170625.png" alt></p>
<p>填写名字并勾选<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314171011.png" alt></p>
<p><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314170934.png" alt></p>
<p>该Toke码只会出现这一次记得保存，在接下来的PicGo配置中将会使用<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314171150.png" alt></p>
<h4 id="3-2、PicGo相关相关配置"><a href="#3-2、PicGo相关相关配置" class="headerlink" title="3.2、PicGo相关相关配置"></a>3.2、PicGo相关相关配置</h4><ul>
<li><p>1、下载安装并运行<br>由于我使用的是MarkDown格式的图片链接所以，将链接格式默认设置为MarkDown同时设置gitHub为默认图床<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314173035.png" alt></p>
</li>
<li><p>2、配置图床<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314171823.png" alt></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设定仓库名的时候，是按照“账户名/仓库名的格式填写”</span><br><span class="line">分支名统一填写“master”</span><br><span class="line">将之前的Token黏贴在这里</span><br><span class="line">存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</span><br><span class="line">自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、PicGo相关设置<br>包括更新及修改快捷键等设置在其中完成即可<br><img src="https://raw.githubusercontent.com/WuliYongShun/PictureHouse/master/img/20200314172523.png" alt></p>
</li>
<li><p>3、重启将配置进行生效设置</p>
</li>
</ul>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>使用截图软件等等图后图片会自动在剪贴板去，使用快捷键可直接上传图片到图床，同时PicGo会在剪贴板自动生成相关格式连接，直接粘贴至MarkDown中即可。</p>
<h3 id="5、使用中遇到的问题"><a href="#5、使用中遇到的问题" class="headerlink" title="5、使用中遇到的问题"></a>5、使用中遇到的问题</h3><h3 id="5-1、提示上传失败，服务端出错，请重试"><a href="#5-1、提示上传失败，服务端出错，请重试" class="headerlink" title="5.1、提示上传失败，服务端出错，请重试"></a>5.1、提示上传失败，服务端出错，请重试</h3><p>由于我配置的都是正确的，软件总是间歇式上传失败，经过百度经验<code>打开PicGo的设置-设置server</code>将是否开启server按钮关闭再打开能够解决问题<em>暂时理解为重启连接服务器问题</em>。</p>
]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32-单片机应用笔记</title>
    <url>/2020/03/04/STM32-%E5%8D%95%E7%89%87%E6%9C%BA%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、使用笔记"><a href="#一、使用笔记" class="headerlink" title="一、使用笔记"></a>一、使用笔记</h1><h3 id="1、关于遇到使用Stm32CubeMX生成带FreeRTOS代码使用printf打印死机问题"><a href="#1、关于遇到使用Stm32CubeMX生成带FreeRTOS代码使用printf打印死机问题" class="headerlink" title="1、关于遇到使用Stm32CubeMX生成带FreeRTOS代码使用printf打印死机问题"></a>1、关于遇到使用Stm32CubeMX生成带FreeRTOS代码使用printf打印死机问题</h3><h4 id="1）首先在usart-c中的用户代码块中添加如下代码："><a href="#1）首先在usart-c中的用户代码块中添加如下代码：" class="headerlink" title="1）首先在usart.c中的用户代码块中添加如下代码："></a>1）首先在usart.c中的用户代码块中添加如下代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef __GNUC__</span><br><span class="line"></span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	// 注意下面第一个参数是&amp;huart1，因为cubemx配置了串口1自动生成的</span><br><span class="line">	HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;ch, 1, HAL_MAX_DELAY);</span><br><span class="line">	return ch;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _write(int file, char *ptr, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int DataIdx;</span><br><span class="line">	for (DataIdx = 0; DataIdx &lt; len;DataIdx++)</span><br><span class="line">	&#123;</span><br><span class="line">	  __io_putchar(*ptr++);</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure>

<p>将以上代码加入后，在主函数中可以使用printf函数打印输出，但是不支持浮点数据打印。</p>
<h4 id="2）添加浮点输出打印"><a href="#2）添加浮点输出打印" class="headerlink" title="2）添加浮点输出打印"></a>2）添加浮点输出打印</h4><p>就此便可直接通过printf输出数据但是没法输出浮点数，我们可以进行如下设置即可完美支持浮点数的输出。在工程属性下找到C/C++ build-&gt;Settings-&gt;Tool Settings-&gt;C Linker-&gt;Miscellaneous-&gt;Other options 选项空中填写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u_printf_float</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi = 3.1415926;</span><br><span class="line">printf(&quot;%.3f\r\n&quot;,pi);</span><br></pre></td></tr></table></figure>

<p>即可。到此为止TrueStudio即可支持printf的所有数据类型输出。</p>
<p>至此为止，所有打印都可以正常完成，<strong>但是</strong>问题来了，在freeRTOS任务快中调用打印printf时，操作系统就会死机，于是各种寻找解决办法。</p>
<h4 id="3）解决freeRTOS任务块打印死机问题"><a href="#3）解决freeRTOS任务块打印死机问题" class="headerlink" title="3）解决freeRTOS任务块打印死机问题"></a>3）解决freeRTOS任务块打印死机问题</h4><p>在工程目录下，按照如下路径添加微小printf实现：<br>新建-&gt;其他-库函数-&gt;微小printf实现(选择添加路径，然后确认添加完微小printf实现后，即可在任务代码块中使用printf函数)。</p>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>STM</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeeRTOS-应用笔记</title>
    <url>/2020/03/01/FreeRTOS%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="FreeRTOS系统使用笔记"><a href="#FreeRTOS系统使用笔记" class="headerlink" title="FreeRTOS系统使用笔记"></a>FreeRTOS系统使用笔记</h1><h2 id="一、FreeRTOS"><a href="#一、FreeRTOS" class="headerlink" title="一、FreeRTOS"></a>一、FreeRTOS</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>免费的可以裁剪的实时操作系统</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>​    FreeRTOS的内核是支持抢占式，合作式和时间片调度；<br>​    等等……</p>
<h3 id="3、freeRTOS的使用"><a href="#3、freeRTOS的使用" class="headerlink" title="3、freeRTOS的使用"></a>3、freeRTOS的使用</h3><p>官网地址： <a href="http://www.freertos.org" target="_blank" rel="noopener">www.freertos.org</a><br>使用方法： 官网文档</p>
<h2 id="二、移植FreeRTOS"><a href="#二、移植FreeRTOS" class="headerlink" title="二、移植FreeRTOS"></a>二、移植FreeRTOS</h2><p>不建议手动去移植，针对STM32单片机，直接使用CubeMX软件直接生成源码使用。</p>
<h2 id="三、FreeRTOS系统相关配置"><a href="#三、FreeRTOS系统相关配置" class="headerlink" title="三、FreeRTOS系统相关配置"></a>三、FreeRTOS系统相关配置</h2><h3 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h3><p>使用STMCubeMX生成的操作系统配置文件在一下文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;FreeRTOSConfig.h&quot;</span><br></pre></td></tr></table></figure>

<p>说明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*-----------------------------------------------------------</span><br><span class="line"> * Application specific definitions.</span><br><span class="line"> *</span><br><span class="line"> * These definitions should be adjusted for your particular hardware and</span><br><span class="line"> * application requirements.</span><br><span class="line"> *</span><br><span class="line"> * These parameters and more are described within the &apos;configuration&apos; section of the</span><br><span class="line"> * FreeRTOS API documentation available on the FreeRTOS.org web site.</span><br><span class="line"> *</span><br><span class="line"> * See http://www.freertos.org/a00110.html</span><br><span class="line"> *----------------------------------------------------------*/</span><br></pre></td></tr></table></figure>

<p>我们可以通过该配置文件，对系统进行裁剪操作（推荐直接使用STMCube 进行配置同时生成代码更方便），这个文件对于操作系统来说比较重要。</p>
<p><em>配置文件中主要有两种类型的配置：</em></p>
<p>1、”#INCLUDE_”开头的宏；</p>
<p>2、”config”开头的宏；</p>
<h3 id="2、”-INCLUDE-”开头的宏；"><a href="#2、”-INCLUDE-”开头的宏；" class="headerlink" title="2、”#INCLUDE_”开头的宏；"></a>2、”#INCLUDE_”开头的宏；</h3><p>通过配置此类型的宏定义，来表示使能或失能FreeRTOS中的API函数，作用就是配置FreeRTOS中的可选API函数。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Set the following definitions to 1 to include the API function, or zero</span><br><span class="line">to exclude the API function. */</span><br><span class="line">#define INCLUDE_vTaskPrioritySet            1</span><br><span class="line">#define INCLUDE_uxTaskPriorityGet           1</span><br><span class="line">#define INCLUDE_vTaskDelete                 1</span><br><span class="line">#define INCLUDE_vTaskCleanUpResources       0</span><br><span class="line">#define INCLUDE_vTaskSuspend                1</span><br><span class="line">#define INCLUDE_vTaskDelayUntil             0</span><br><span class="line">#define INCLUDE_vTaskDelay                  1</span><br><span class="line">#define INCLUDE_xTaskGetSchedulerState      1</span><br></pre></td></tr></table></figure>

<h3 id="3、”config”开头的宏"><a href="#3、”config”开头的宏" class="headerlink" title="3、”config”开头的宏"></a>3、”config”开头的宏</h3><p>通过配置此类型的宏定义，来配置和裁剪FreeRTOS的相关功能和参数。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Ensure definitions are only used by the compiler, and not by the assembler. */</span><br><span class="line">#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span><br><span class="line">  #include &lt;stdint.h&gt;</span><br><span class="line">  extern uint32_t SystemCoreClock;</span><br><span class="line">  void xPortSysTickHandler(void);</span><br><span class="line">#endif</span><br><span class="line">#define configUSE_PREEMPTION                     1</span><br><span class="line">#define configSUPPORT_STATIC_ALLOCATION          1</span><br><span class="line">#define configSUPPORT_DYNAMIC_ALLOCATION         1</span><br><span class="line">#define configUSE_IDLE_HOOK                      0</span><br><span class="line">#define configUSE_TICK_HOOK                      0</span><br><span class="line">#define configCPU_CLOCK_HZ                       ( SystemCoreClock )</span><br><span class="line">#define configTICK_RATE_HZ                       ((TickType_t)1000)</span><br><span class="line">#define configMAX_PRIORITIES                     ( 32 )</span><br><span class="line">#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</span><br><span class="line">#define configTOTAL_HEAP_SIZE                    ((size_t)3072)</span><br><span class="line">#define configMAX_TASK_NAME_LEN                  ( 16 )</span><br><span class="line">#define configUSE_16_BIT_TICKS                   0</span><br><span class="line">#define configUSE_MUTEXES                        1</span><br><span class="line">#define configQUEUE_REGISTRY_SIZE                8</span><br><span class="line">#define configUSE_PORT_OPTIMISED_TASK_SELECTION  1</span><br><span class="line"></span><br><span class="line">/* Co-routine definitions. */</span><br><span class="line">#define configUSE_CO_ROUTINES                    0</span><br><span class="line">#define configMAX_CO_ROUTINE_PRIORITIES          ( 2 )</span><br></pre></td></tr></table></figure>

<h2 id="四、系统任务相关API函数"><a href="#四、系统任务相关API函数" class="headerlink" title="四、系统任务相关API函数"></a>四、系统任务相关API函数</h2><p>系统任务主要包括以下几个方面的API函数：</p>
<p>1、任务创建和删除API函数（包括动态方法和静态方法）；</p>
<p>2、任务的挂起和恢复API函数；</p>
<h3 id="1、任务创建和删除相关API函数"><a href="#1、任务创建和删除相关API函数" class="headerlink" title="1、任务创建和删除相关API函数"></a>1、任务创建和删除相关API函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xTaskCreate()</td>
<td align="left">动态方法创建一个任务</td>
</tr>
<tr>
<td align="left">xTaskCreateStatic()</td>
<td align="left">静态方法创建一个任务</td>
</tr>
<tr>
<td align="left">xTaskCreateRestricted()</td>
<td align="left">创建一个使用MPU进行限制的任务，相关内存使用动态内存分配</td>
</tr>
<tr>
<td align="left">vTaskDelete()</td>
<td align="left">删除一个任务</td>
</tr>
</tbody></table>
<h4 id="1-1-动态创建函数-xTaskCreate-："><a href="#1-1-动态创建函数-xTaskCreate-：" class="headerlink" title="1.1 动态创建函数 xTaskCreate()："></a>1.1 动态创建函数 xTaskCreate()：</h4><p>动态创建任务原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,</span><br><span class="line">							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span><br><span class="line">							const configSTACK_DEPTH_TYPE usStackDepth,</span><br><span class="line">							void * const pvParameters,</span><br><span class="line">							UBaseType_t uxPriority,</span><br><span class="line">							TaskHandle_t * const pxCreatedTask )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>pxTaskCode：            任务函数；</p>
<p>pcName：                  任务名字，一般用于追踪和调试，任务名字长度不能超过configMAX_TASK_NAME_LEN；</p>
<p>usStackDepth：        任务堆栈大小，使用申请到的堆栈是usStackDepth的4倍，空闲任务的堆栈大小为 configMINIMAL_STACK_SIZE</p>
<p>uxPriority：                任务优先级，范围是0~configMAX_TASK_NAME_LEN-1；</p>
<p>pxCreatedTask：        任务句柄，任务创建成功后会返回这个任务句柄，这个句柄其实就是任务的任务堆栈。此参数就用来保存这个任务句柄。其他API函数就可能会使用到这个句柄。</p>
<p><strong>返回值</strong></p>
<p>pdPASS:                        任务创建成功</p>
<p>errCOILD_NOT_ALLOCATE_REQUIRED_MEMORY:    任务创建失败因为内存不足。</p>
<h4 id="1-2-动态创建函数-xTaskCreateStatic-："><a href="#1-2-动态创建函数-xTaskCreateStatic-：" class="headerlink" title="1.2 动态创建函数 xTaskCreateStatic()："></a>1.2 动态创建函数 xTaskCreateStatic()：</h4><p>此函数和xTaskCreate()的功能相同，也是用来创建任务的，但是使用此函数的任务所需要的RAM需要用户来提供。如果要使用此函数的话需要将宏configSUPPORT_STATIC_ALLOCATION定义为1。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,</span><br><span class="line">									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span><br><span class="line">									const uint32_t ulStackDepth,</span><br><span class="line">									void * const pvParameters,</span><br><span class="line">									UBaseType_t uxPriority,</span><br><span class="line">									StackType_t * const puxStackBuffer,</span><br><span class="line">									StaticTask_t * const pxTaskBuffer )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>pxTaskCode:                任务函数</p>
<p>pcName:                      任务名字，一般用于追踪和调试，任务名字长度不能超过configMAX_TASK_NAME_LEN；</p>
<p>ulStackDepth:              任务堆栈大小，由于本函数是静态方法创建任务，所以任务堆栈由用户给出，一般是个数组，此参数就是这个数组的大小；</p>
<p>pvParameters:            传递任务函数的参数；</p>
<p>uxPriority:                    任务优先级，范围是0~configMAX_TASK_NAME_LEN-1；</p>
<p>puxStackBuffer:          任务堆栈，一般为数组，数组类型要为StackType_t类型；</p>
<p>pxTaskBuffer:              任务控制块。</p>
<p><strong>返回值</strong></p>
<p>NULL:                            任务创建失败，puxStackBuffer或pxTaskBuffer为NULL的时候会导致这个错误的发生；</p>
<p>其他值：                        任务创建成功。返回值是任务的句柄。</p>
<h4 id="1-3、函数xTaskCreateRestricted"><a href="#1-3、函数xTaskCreateRestricted" class="headerlink" title="1.3、函数xTaskCreateRestricted()"></a>1.3、函数xTaskCreateRestricted()</h4><p>此函数也是用来创建任务的，只是此函数要求所使用的MCU有MPU（内存保护单元），用此函数创建的任务会受到MPU的保护。其他的功能和函数xTaskCreate()一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>pxTaskDefinition：        指向一个结构体TaskParameters_t,这个结构体描述了任务的任务函数堆栈大小、优先级等。此结构体在文件task.h中有定义；</p>
<p>pxCreatedTask:              任务句柄。</p>
<p><strong>返回值：</strong></p>
<p>pdPASS:                            任务创建成功；</p>
<p>其他值：                            任务未创建成功，很有可能是因为FreeRTOS的堆太小了。</p>
<h4 id="1、4任务删除函数vTaskDelete"><a href="#1、4任务删除函数vTaskDelete" class="headerlink" title="1、4任务删除函数vTaskDelete()"></a>1、4任务删除函数vTaskDelete()</h4><p>删除上述的任意任务创建函数，被删除的任务不在存在，也就是说不会进入运行态。静态任务直接被释放掉内存，动态创建任务在空闲任务中被释放掉，一次调用函数vTaskDelete()删除任务以后必须给空闲任务一定的运行时间。</p>
<p><em>只有那些由内核分配给任务的内存才会在任务删除以后会被释放掉，用户分配给任务的内存需要用户自行释放掉，比如摸个任务中用户调用函数pvPortMalloc()分配了500个字节的内存，那么在此任务被删除后用户也必须调用函数vPortFree()将这500个字节的内存释放掉，否则会导致内存泄露。</em>此函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vTaskDelete( TaskHandle_t xTaskToDelete )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>xTaskToDelete：        要删除任务的任务句柄。</p>
<p><strong>返回值：</strong></p>
<p>无</p>
<h3 id="2、任务挂起和恢复相关API函数"><a href="#2、任务挂起和恢复相关API函数" class="headerlink" title="2、任务挂起和恢复相关API函数"></a>2、任务挂起和恢复相关API函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vTaskSuspend()</td>
<td>挂起一个任务</td>
</tr>
<tr>
<td>vTaskResume()</td>
<td>恢复一个任务的运行</td>
</tr>
<tr>
<td>xTaskResumeFromISR()</td>
<td>中断服务函数中恢复一个任务的运行</td>
</tr>
</tbody></table>
<h4 id="2-1、vTaskSuspend-函数"><a href="#2-1、vTaskSuspend-函数" class="headerlink" title="2.1、vTaskSuspend()函数"></a>2.1、vTaskSuspend()函数</h4><p>此函数用于将某个任务设置为挂起态，进入挂起态的任务永远都不会进入运行态。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void vTaskSuspend( TaskHandle_t xTaskToSuspend )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>xTaskToSuspend:要挂起的任务的任务句柄，创建任务的时候会为每个任务分配一个任务句柄。<em>注意如果参数为NULL的话表示挂起任务自己。</em></p>
<p><strong>返回值：</strong></p>
<p>无</p>
<h4 id="2-2、vTaskResume-函数"><a href="#2-2、vTaskResume-函数" class="headerlink" title="2.2、vTaskResume()函数"></a>2.2、vTaskResume()函数</h4><p>将一个挂起任务恢复到就绪态，只有通过函数vTaskSuspend()设置为挂起态的任务才可以使用vTaskResume()恢复，函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void vTaskResume( TaskHandle_t xTaskToResume )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>xTaskToResume：    要恢复任务的任务句柄。</p>
<p><strong>返回值：</strong></p>
<p>无</p>
<h4 id="2-3、vTaskResumeFromISR"><a href="#2-3、vTaskResumeFromISR" class="headerlink" title="2.3、vTaskResumeFromISR()"></a>2.3、vTaskResumeFromISR()</h4><p>此函数是vTaskResume()的中断版本，用于在中断服务函数中恢复一个任务。函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<p>xTaskToResume：    要恢复任务的任务句柄。</p>
<p><strong>返回值：</strong></p>
<p>pdTRUE:        恢复运行的任务的任务优先级等于或者高于正在运行的任务(被中断打断的任务),这意味着在退出中断服务函数以后必须进行一次上下文切换；</p>
<p>pdFALSE：    恢复运行的任务的任务优先级低于当前正在运行的任务(被中断打断的任务),这意味着在退出中断服务函数等以后不需要进行上下文切换。</p>
<p><em>例如：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//任务句柄</span><br><span class="line">extern TaskHandle_t Task2Task_Handler;</span><br><span class="line"></span><br><span class="line">//外部中断4服务程序</span><br><span class="line">void EXTI4_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	BaseType_t YieldRequired;</span><br><span class="line">	</span><br><span class="line">	delay_xms(20);	//消抖</span><br><span class="line">	if(KEY0==0)	 </span><br><span class="line">	&#123;				 </span><br><span class="line">		YieldRequired=xTaskResumeFromISR(Task2Task_Handler);//恢复任务2</span><br><span class="line">		printf(&quot;恢复任务2的运行!\r\n&quot;);</span><br><span class="line">		if(YieldRequired==pdTRUE)</span><br><span class="line">		&#123;</span><br><span class="line">			/*如果函数xTaskResumeFromISR()返回值为pdTRUE，那么说明要恢复的这个</span><br><span class="line">			任务的任务优先级等于或者高于正在运行的任务(被中断打断的任务),所以在</span><br><span class="line">			退出中断的时候一定要进行上下文切换！*/</span><br><span class="line">			portYIELD_FROM_ISR(YieldRequired);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		 </span><br><span class="line">	 EXTI_ClearITPendingBit(EXTI_Line4);//清除LINE4上的中断标志位  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、任务临界段保护代码"><a href="#五、任务临界段保护代码" class="headerlink" title="五、任务临界段保护代码"></a>五、任务临界段保护代码</h2><p>临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段，比如有外设的初始化需要严格的时序，初始化过程中不能被打断。FreeRTOS在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。FreeRTOS系统本身就有很多临界段代码，这些代码都加入了临界段代码保护，我们在写自己的用户程序的时候有些地方也需要添加临界段代码保护。</p>
<p><em>FreeRTOS与临界段代码保护有关的函数有4个：</em></p>
<p>​    taskENTER_CRITICAL();</p>
<p>​    taskEXIT_CRITICAL();</p>
<p>​    taskENTER_CRITICAL_FROM_ISR();</p>
<p>​    taskEXIT_CRITICAL_FROM_ISR();</p>
<p>这四个函数是在task.h文件中的宏定义，这四个函数的区别是前两个是任务级的临界段保护代码，后两个是中断级的临界段代码保护。</p>
<h3 id="1、任务级临界段代码保护"><a href="#1、任务级临界段代码保护" class="headerlink" title="1、任务级临界段代码保护"></a>1、任务级临界段代码保护</h3><p>taskENTER_CRITICAL()和    taskEXIT_CRITICAL()是任务级别的临界代码保护，一个是进入临界段，一个是退出临界段，这两个函数是成对使用的，函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define taskENTER_CRITICAL()		portENTER_CRITICAL()</span><br><span class="line">#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()</span><br></pre></td></tr></table></figure>

<p>而portENTER_CRITICAL()和portEXIT_CRITICAL()也是宏定义，在文件portmacro.h中有定义，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define portENTER_CRITICAL()					vPortEnterCritical()</span><br><span class="line">#define portEXIT_CRITICAL()						vPortExitCritical()</span><br></pre></td></tr></table></figure>

<p>函数vPortEnterCritical()和vPortExitCritical()在文件port.c中，函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void vPortEnterCritical( void )</span><br><span class="line">&#123;</span><br><span class="line">	portDISABLE_INTERRUPTS();</span><br><span class="line">	uxCriticalNesting++;</span><br><span class="line"></span><br><span class="line">	/* This is not the interrupt safe version of the enter critical function so</span><br><span class="line">	assert() if it is being called from an interrupt context.  Only API</span><br><span class="line">	functions that end in &quot;FromISR&quot; can be used in an interrupt.  Only assert if</span><br><span class="line">	the critical nesting count is 1 to protect against recursive calls if the</span><br><span class="line">	assert function also uses a critical section. */</span><br><span class="line">	if( uxCriticalNesting == 1 )</span><br><span class="line">	&#123;</span><br><span class="line">		configASSERT( ( portNVIC_INT_CTRL_REG &amp; portVECTACTIVE_MASK ) == 0 );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vPortExitCritical( void )</span><br><span class="line">&#123;</span><br><span class="line">	configASSERT( uxCriticalNesting );</span><br><span class="line">	uxCriticalNesting--;</span><br><span class="line">	if( uxCriticalNesting == 0 )</span><br><span class="line">	&#123;</span><br><span class="line">		portENABLE_INTERRUPTS();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务级临界代码保护使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void taskcritical_test(void)</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		taskENTER_CRITICAL();	//进入临界</span><br><span class="line">		total_num += 0.01f;</span><br><span class="line">		printf(&quot;total_num的值为：%.4f\r\n&quot;,total_num);</span><br><span class="line">		taskEXIT_CRITICAL();	//退出临界保护</span><br><span class="line">		vTaskDelay(1000);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意临界区代码一定要精简，因为进入临界区会关闭中断，这样会导致优先级低于configMAX_SYSCALL_INTERRUPT_PRIORITY的中断得不到及时的响应。</em></p>
<h3 id="2、中断临界段保护代码"><a href="#2、中断临界段保护代码" class="headerlink" title="2、中断临界段保护代码"></a>2、中断临界段保护代码</h3><p> 函数taskENTER_CRITICAL_FROM_ISR()和 taskEXIT_CRITICAL_FROM_ISR()中断界别临界段代码保护，是用在中断服务程序中的，而且这个中断的优先级一定要低于configMAX_SYSCALL_INTERRUPT_PRIORITY。这两个函数在task.h文件中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()</span><br><span class="line">#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )</span><br></pre></td></tr></table></figure>

<p>接着找到portSET_INTERRUPT_MASK_FROM_ISR()和portCLEAR_INTERRUPT_MASK_FROM_ISR( x )在portmaro.h中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()</span><br><span class="line">#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)</span><br></pre></td></tr></table></figure>

<p><em>vPortSetBASEPRI</em>函数就是给BASEPRI寄存器中写入一个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*-----------------------------------------------------------*/</span><br><span class="line">portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )</span><br><span class="line">&#123;</span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">		&quot;	msr basepri, %0	&quot; :: &quot;r&quot; ( ulNewMaskValue ) : &quot;memory&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数ulPortRaiseBASEPRI()在文件portmacro.h中定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )</span><br><span class="line">&#123;</span><br><span class="line">uint32_t ulOriginalBASEPRI, ulNewBASEPRI;</span><br><span class="line"></span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">		&quot;	mrs %0, basepri											\n&quot; \</span><br><span class="line">		&quot;	mov %1, %2												\n&quot; \</span><br><span class="line">		&quot;	msr basepri, %1											\n&quot; \</span><br><span class="line">		&quot;	isb														\n&quot; \</span><br><span class="line">		&quot;	dsb														\n&quot; \</span><br><span class="line">		:&quot;=r&quot; (ulOriginalBASEPRI), &quot;=r&quot; (ulNewBASEPRI) : &quot;i&quot; ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : &quot;memory&quot;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	/* This return will not be reached but is necessary to prevent compiler</span><br><span class="line">	warnings. */</span><br><span class="line">	return ulOriginalBASEPRI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先读出BASEPRI的值，保存在ulOriginalBASEPRI中；将configMAX_SYSCALL_INTERRUPT_PRIORITY写入到寄存器BASEPRI；</p>
<p>返回ulOriginalBASEPRI，退出临界区代码保护的时候要用到此值。</p>
<p>中断级临界代码保护使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定时器中断服务函数</span><br><span class="line">void TIM3_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">	if(TIM_GetITStatus(TIM3,TIM_IT_Update) == SET) //溢出中断</span><br><span class="line">	&#123;</span><br><span class="line">		status_value = taskENTER_CRITICAL_FROM_ISR(); //进入临界保护</span><br><span class="line">		total_num += 1;</span><br><span class="line">		printf(&quot;total_num的值为：%.4f\r\n&quot;,total_num);</span><br><span class="line">		taskEXIT_CRITICAL_FROM_ISR( status_value ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	TIM_ClearITPendingBit(TIM3, TIM_IT_Update);	//清除中断标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、任务状态查询及任务相关API函数"><a href="#六、任务状态查询及任务相关API函数" class="headerlink" title="六、任务状态查询及任务相关API函数"></a>六、任务状态查询及任务相关API函数</h2><h3 id="1、主要函数"><a href="#1、主要函数" class="headerlink" title="1、主要函数"></a>1、主要函数</h3><p><img src="H:%5CZPanDisk%5C%E6%96%87%E4%BB%B6%5CShunWork%5CMyblog%5Csource_posts%5CPICTURE%5C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8.png" alt="任务列表"></p>
<h3 id="2、函数的使用案例"><a href="#2、函数的使用案例" class="headerlink" title="2、函数的使用案例"></a>2、函数的使用案例</h3><p><strong>如下案例在自己建立的任务循环之前的初始化之前执行，同时保证printf重定向到串口，针对某些API函数不能直接使用，需要在FreeRTOSConfig.h操作系统配置文件中进行裁剪，下方附本系统实现的配置文件源码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UBaseType_t TaskNum, x;</span><br><span class="line">TaskStatus_t *StatusArray;</span><br><span class="line">uint32_t TotalRunTime;</span><br><span class="line"></span><br><span class="line">/* 1、測試函數uxTaskGetNumberState( )的使用 */</span><br><span class="line">printf(&quot;/********1、函数uxTaskGetSystemState()的使用**********/\r\n&quot;);</span><br><span class="line">/* 获取系统任务数量 */</span><br><span class="line">TaskNum = uxTaskGetNumberOfTasks( );</span><br><span class="line"></span><br><span class="line">/* 申请内存 */</span><br><span class="line">StatusArray = pvPortMalloc( TaskNum * sizeof( TaskStatus_t ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 判断内存是否申请成功 */</span><br><span class="line">if( StatusArray != NULL )</span><br><span class="line">&#123;</span><br><span class="line">	/* 包括：任务信息存储数组   任务信息存储数组大小     保存系统总的运行时间 */</span><br><span class="line">	TaskNum = uxTaskGetSystemState( ( TaskStatus_t * )StatusArray, ( UBaseType_t )TaskNum, ( uint32_t * )&amp;TotalRunTime );</span><br><span class="line">	printf(&quot;TaskName\t\tPriority\t\tTaskNumber\t\t\r\n&quot;);</span><br><span class="line">	for( x = 0; x &lt; TaskNum; x++ )</span><br><span class="line">	&#123;</span><br><span class="line">		/* 通过串口打印出获取到的系统任务的有关信息，比如任务名称、任务优先级和任务编号。 */</span><br><span class="line">		printf(&quot;%s\t\t%d\t\t\t%d\t\t\t\r\n&quot;,StatusArray[ x ].pcTaskName, (int)StatusArray[ x ].uxCurrentPriority, (int)StatusArray[ x ].xTaskNumber );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vPortFree( StatusArray );</span><br><span class="line">printf(&quot;/***************************结束***************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line"></span><br><span class="line">/* 2、函数vTaskGetInfo()的使用 */</span><br><span class="line">TaskHandle_t TaskHandle;</span><br><span class="line">TaskStatus_t TaskStatus;</span><br><span class="line"></span><br><span class="line">printf(&quot;/* *******************测试2，函数vTaskGetInfo()的使用******************** */\r\n&quot;);</span><br><span class="line">TaskHandle = xTaskGetHandle( &quot;myTask1_App&quot; );	//参数为查看任务名字</span><br><span class="line"></span><br><span class="line">/* 检查句柄是够为空 */</span><br><span class="line">configASSERT( TaskHandle );</span><br><span class="line"></span><br><span class="line">/* 获取Task1_App的任务信息 */</span><br><span class="line">// Use the handle to obtain further information about the task.</span><br><span class="line">vTaskGetInfo( TaskHandle,	//任务句柄</span><br><span class="line">			  &amp;TaskStatus,	//任务信息结构体</span><br><span class="line">			  pdTRUE, // Include the high water mark in xTaskDetails.</span><br><span class="line">			  eInvalid ); // Include the task state in xTaskDetails.</span><br><span class="line"></span><br><span class="line">//通过串口打印出指定任务的有关信息。</span><br><span class="line">printf(&quot;任务名:                %s\r\n&quot;,TaskStatus.pcTaskName);</span><br><span class="line">printf(&quot;任务编号:              %d\r\n&quot;,(int)TaskStatus.xTaskNumber);</span><br><span class="line">printf(&quot;任务壮态:              %d\r\n&quot;,TaskStatus.eCurrentState);</span><br><span class="line">printf(&quot;任务当前优先级:        %d\r\n&quot;,(int)TaskStatus.uxCurrentPriority);</span><br><span class="line">printf(&quot;任务基优先级:          %d\r\n&quot;,(int)TaskStatus.uxBasePriority);</span><br><span class="line">printf(&quot;任务堆栈基地址:        %#x\r\n&quot;,(int)TaskStatus.pxStackBase);</span><br><span class="line">printf(&quot;任务堆栈历史剩余最小值:%d\r\n&quot;,TaskStatus.usStackHighWaterMark);</span><br><span class="line"></span><br><span class="line">printf(&quot;/**************************结束***************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 3、函数eTaskState()的作用 */</span><br><span class="line">eTaskState TaskState;</span><br><span class="line">char TaskInfo[ 10 ];</span><br><span class="line">printf(&quot;/***********测试3，函数eTaskGetState()的使用*************/\r\n&quot;);</span><br><span class="line">TaskHandle = xTaskGetHandle( &quot;defaultTask&quot; );	//当前运行任务名字</span><br><span class="line">TaskState = eTaskGetState( TaskHandle );</span><br><span class="line">memset( TaskInfo, 0, 10 );</span><br><span class="line"></span><br><span class="line">switch((int)TaskState)</span><br><span class="line">&#123;</span><br><span class="line">	case 0:</span><br><span class="line">		sprintf(TaskInfo,&quot;Running&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 1:</span><br><span class="line">		sprintf(TaskInfo,&quot;Ready&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		sprintf(TaskInfo,&quot;Suspend&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 3:</span><br><span class="line">		sprintf(TaskInfo,&quot;Delete&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 4:</span><br><span class="line">		sprintf(TaskInfo,&quot;Invalid&quot;);</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;任务壮态值:%d,对应的壮态为:%s\r\n&quot;,TaskState,TaskInfo);</span><br><span class="line">printf(&quot;/**************************结束**************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line"></span><br><span class="line">/* 4、函数vTaskList()的使用 */</span><br><span class="line">printf( &quot;/*************4、函数vTaskList()的使用*************/\r\n&quot; );</span><br><span class="line"></span><br><span class="line">vTaskList( InfoBuffer );		//获取所有任务的信息</span><br><span class="line">printf( &quot;%s\r\n&quot;,InfoBuffer );	//通过串口打印所有任务的信息</span><br><span class="line">printf( &quot;/**************************结束**************************/\r\n&quot; );</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br><span class="line">printf(&quot;/********************************************************/\r\n&quot;);</span><br></pre></td></tr></table></figure>

<p>系统配置文件FreeRTOSConfig.h源码：</p>
<p>  <a href="Src\FreeRTOSConfig.h">FreeRTOSConfig.h</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* USER CODE BEGIN Header */</span><br><span class="line">/*</span><br><span class="line"> * FreeRTOS Kernel V10.0.1</span><br><span class="line"> * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.</span><br><span class="line"> *</span><br><span class="line"> * Permission is hereby granted, free of charge, to any person obtaining a copy of</span><br><span class="line"> * this software and associated documentation files (the &quot;Software&quot;), to deal in</span><br><span class="line"> * the Software without restriction, including without limitation the rights to</span><br><span class="line"> * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span><br><span class="line"> * the Software, and to permit persons to whom the Software is furnished to do so,</span><br><span class="line"> * subject to the following conditions:</span><br><span class="line"> *</span><br><span class="line"> * The above copyright notice and this permission notice shall be included in all</span><br><span class="line"> * copies or substantial portions of the Software.</span><br><span class="line"> *</span><br><span class="line"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span><br><span class="line"> * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span><br><span class="line"> * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span><br><span class="line"> * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span><br><span class="line"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br><span class="line"> *</span><br><span class="line"> * http://www.FreeRTOS.org</span><br><span class="line"> * http://aws.amazon.com/freertos</span><br><span class="line"> *</span><br><span class="line"> * 1 tab == 4 spaces!</span><br><span class="line"> */</span><br><span class="line">/* USER CODE END Header */</span><br><span class="line"></span><br><span class="line">#ifndef FREERTOS_CONFIG_H</span><br><span class="line">#define FREERTOS_CONFIG_H</span><br><span class="line"></span><br><span class="line">/*-----------------------------------------------------------</span><br><span class="line"> * Application specific definitions.</span><br><span class="line"> *</span><br><span class="line"> * These definitions should be adjusted for your particular hardware and</span><br><span class="line"> * application requirements.</span><br><span class="line"> *</span><br><span class="line"> * These parameters and more are described within the &apos;configuration&apos; section of the</span><br><span class="line"> * FreeRTOS API documentation available on the FreeRTOS.org web site.</span><br><span class="line"> *</span><br><span class="line"> * See http://www.freertos.org/a00110.html</span><br><span class="line"> *----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN Includes */   	      </span><br><span class="line">/* Section where include file can be added */</span><br><span class="line">/* USER CODE END Includes */ </span><br><span class="line"></span><br><span class="line">/* Ensure definitions are only used by the compiler, and not by the assembler. */</span><br><span class="line">#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span><br><span class="line">  #include &lt;stdint.h&gt;</span><br><span class="line">  extern uint32_t SystemCoreClock;</span><br><span class="line">#endif</span><br><span class="line">#define configUSE_PREEMPTION                     1</span><br><span class="line">#define configSUPPORT_STATIC_ALLOCATION          1</span><br><span class="line">#define configSUPPORT_DYNAMIC_ALLOCATION         1</span><br><span class="line">#define configUSE_IDLE_HOOK                      0</span><br><span class="line">#define configUSE_TICK_HOOK                      0</span><br><span class="line">#define configCPU_CLOCK_HZ                       ( SystemCoreClock )</span><br><span class="line">#define configTICK_RATE_HZ                       ((TickType_t)1000)</span><br><span class="line">#define configMAX_PRIORITIES                     ( 32 )</span><br><span class="line">#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)</span><br><span class="line">#define configTOTAL_HEAP_SIZE                    ((size_t)3072)</span><br><span class="line">#define configMAX_TASK_NAME_LEN                  ( 16 )</span><br><span class="line">#define configUSE_TRACE_FACILITY                 1</span><br><span class="line">#define configUSE_STATS_FORMATTING_FUNCTIONS     1</span><br><span class="line">#define configUSE_16_BIT_TICKS                   0</span><br><span class="line">#define configUSE_MUTEXES                        1</span><br><span class="line">#define configQUEUE_REGISTRY_SIZE                8</span><br><span class="line">#define configUSE_PORT_OPTIMISED_TASK_SELECTION  1</span><br><span class="line"></span><br><span class="line">/* Co-routine definitions. */</span><br><span class="line">#define configUSE_CO_ROUTINES                    0</span><br><span class="line">#define configMAX_CO_ROUTINE_PRIORITIES          ( 2 )</span><br><span class="line"></span><br><span class="line">/* Set the following definitions to 1 to include the API function, or zero</span><br><span class="line">to exclude the API function. */</span><br><span class="line">#define INCLUDE_vTaskPrioritySet            1</span><br><span class="line">#define INCLUDE_uxTaskPriorityGet           1</span><br><span class="line">#define INCLUDE_vTaskDelete                 1</span><br><span class="line">#define INCLUDE_vTaskCleanUpResources       0</span><br><span class="line">#define INCLUDE_vTaskSuspend                1</span><br><span class="line">#define INCLUDE_vTaskDelayUntil             0</span><br><span class="line">#define INCLUDE_vTaskDelay                  1</span><br><span class="line">#define INCLUDE_xTaskGetSchedulerState      1</span><br><span class="line">#define INCLUDE_xQueueGetMutexHolder        1</span><br><span class="line">#define INCLUDE_pcTaskGetTaskName           1</span><br><span class="line">#define INCLUDE_uxTaskGetStackHighWaterMark 1</span><br><span class="line">#define INCLUDE_xTaskGetCurrentTaskHandle   1</span><br><span class="line">#define INCLUDE_eTaskGetState               1</span><br><span class="line">#define INCLUDE_xTaskAbortDelay             1</span><br><span class="line">#define INCLUDE_xTaskGetHandle              1</span><br><span class="line"></span><br><span class="line">/* Cortex-M specific definitions. */</span><br><span class="line">#ifdef __NVIC_PRIO_BITS</span><br><span class="line"> /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */</span><br><span class="line"> #define configPRIO_BITS         __NVIC_PRIO_BITS</span><br><span class="line">#else</span><br><span class="line"> #define configPRIO_BITS         4</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* The lowest interrupt priority that can be used in a call to a &quot;set priority&quot;</span><br><span class="line">function. */</span><br><span class="line">#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY   15</span><br><span class="line"></span><br><span class="line">/* The highest interrupt priority that can be used by any interrupt service</span><br><span class="line">routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL</span><br><span class="line">INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER</span><br><span class="line">PRIORITY THAN THIS! (higher priorities are lower numeric values. */</span><br><span class="line">#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5</span><br><span class="line"></span><br><span class="line">/* Interrupt priorities used by the kernel port layer itself.  These are generic</span><br><span class="line">to all Cortex-M ports, and do not rely on any particular library functions. */</span><br><span class="line">#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="line">/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!</span><br><span class="line">See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */</span><br><span class="line">#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="line"></span><br><span class="line">/* Normal assert() semantics without relying on the provision of an assert.h</span><br><span class="line">header file. */</span><br><span class="line">/* USER CODE BEGIN 1 */</span><br><span class="line">#define configASSERT( x ) if ((x) == 0) &#123;taskDISABLE_INTERRUPTS(); for( ;; );&#125; </span><br><span class="line">/* USER CODE END 1 */</span><br><span class="line"></span><br><span class="line">/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS</span><br><span class="line">standard names. */</span><br><span class="line">#define vPortSVCHandler    SVC_Handler</span><br><span class="line">#define xPortPendSVHandler PendSV_Handler</span><br><span class="line"></span><br><span class="line">/* IMPORTANT: This define is commented when used with STM32Cube firmware, when the timebase source is SysTick,</span><br><span class="line">              to prevent overwriting SysTick_Handler defined within STM32Cube HAL */</span><br><span class="line"> </span><br><span class="line">#define xPortSysTickHandler SysTick_Handler</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN Defines */   	      </span><br><span class="line">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span><br><span class="line">/* USER CODE END Defines */ </span><br><span class="line"></span><br><span class="line">#endif /* FREERTOS_CONFIG_H */</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Embedded</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux7-vi常用命令汇总</title>
    <url>/2020/02/26/Linux7-vi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="vi编辑器的使用"><a href="#vi编辑器的使用" class="headerlink" title="vi编辑器的使用"></a>vi编辑器的使用</h1><p><strong>一个编辑器具备的功能</strong><br>1）打开文件、新建文件、保存文件<br>2）光标移动<br>3）文本编辑<br>4）(多行间|多列间)复制、粘贴、删除<br>5）查找和替换</p>
<p>//=========================================<br><strong>vi编辑器的配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/vim</span><br><span class="line">cp vimrc ~/.vimrc</span><br><span class="line">cd ~</span><br><span class="line">gedit .vimrc</span><br></pre></td></tr></table></figure>

<p>在.vimrc中加入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;关闭兼容功能</span><br><span class="line">set nocompatible </span><br><span class="line">&quot;显示行号</span><br><span class="line">set number</span><br><span class="line">&quot;编辑时 backspace 键设置为2个空格</span><br><span class="line">set backspace=2</span><br><span class="line">&quot;编辑时 tab 键设置为4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot;设置自动对齐为4个空格</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot;搜索时不区分大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot;搜索时高亮显示</span><br><span class="line">set hlsearch</span><br></pre></td></tr></table></figure>

<p>//=========================================</p>
<p><strong>vi编辑器有三种模式</strong><br>1）一般模式（光标移动、复制、粘贴、删除）<br>2）编辑模式（编辑文本）<br>3）命令行模式（查找和替换）</p>
<p><strong>注意：</strong><br>1）当不知道处于何种模式时，按ESC键返回到一般模式。<br>2）wq(write quit)<br>3）i(insert)</p>
<p>//==================================================</p>
<h2 id="1-打开文件、新建文件、保存文件"><a href="#1-打开文件、新建文件、保存文件" class="headerlink" title="1.打开文件、新建文件、保存文件"></a>1.打开文件、新建文件、保存文件</h2><pre><code>vi 文件名
如果文件存在，输入结束后，:wq保存并退出文件
如果文件不存在，输入结束后，:wq就可以新建并保存文件</code></pre><p><em>在编辑完成时，返回一般模式，</em><br>1）输入:w则保存文件，如果已经保存文件，输入:q则退出文件<br>2）直接输入:wq保存并退出<br>3)如果不想保存被修改的内容，则:q!强制退出。</p>
<h2 id="2-进入编辑模式"><a href="#2-进入编辑模式" class="headerlink" title="2.进入编辑模式"></a>2.进入编辑模式</h2><p>i(在光标前开始插入文本)<br>a在光标后开始插入文本<br>o(在当前行之下新开一行，并到行首)</p>
<h2 id="3-光标移动"><a href="#3-光标移动" class="headerlink" title="3.光标移动"></a>3.光标移动</h2><p>在一般模式下，hjkl这四个按键就可以移动光标<br>h(左)<br>j(下)<br>k(上)<br>l(右)</p>
<p>快速的定位到某一行：<br>文件头、文件尾、指定某一行<br>ngg光标移至第n行的行首（n为数字），<br>    如1gg就跳到第一行的行首，就是文件头<br>    如2gg就跳到第二行的行首</p>
<p>G转至文件结尾<br>注意：ngg和G是在一般模式</p>
<p>在某一行如何快速定位到某一列<br>0（数字零）光标移至当前行行首<br>$光标移至当前行行末<br>fx搜索当前行中下一个出现字母x的地方<br>注意：0、$、fx是在一般模式</p>
<p>vi的难点：<br>1）vi操作之前，先判断一下当前是哪一种模式，再看光标所在位置。<br>当你不知道处于何种模式时，使用esc键返回到一般模式。<br>再看光标，难点在于移动光标，可以做到快速切换到某一行某一列。</p>
<h2 id="4-文本复制、粘贴、删除、撤销"><a href="#4-文本复制、粘贴、删除、撤销" class="headerlink" title="4.文本复制、粘贴、删除、撤销"></a>4.文本复制、粘贴、删除、撤销</h2><p>yy复制当前行(y:yank(复制))<br>nyy复制当前行及其后的n-1行(n是数字)</p>
<p>使用P键来粘贴(p:paste)</p>
<p>dd  删除光标所在行(d:delete)<br>ndd 删除当前行及其后的n-1行(n是数字)</p>
<p>按u键来撤销上一步操作</p>
<p>x删除光标所在位置的字符</p>
<p>注意：<br>yy/nyy/dd/ndd/x/u都是在一般模式。</p>
<h2 id="5-查找和替换"><a href="#5-查找和替换" class="headerlink" title="5.查找和替换"></a>5.查找和替换</h2><p>/pattern 从光标开始处向文件尾搜索pattern，后按下n或N<br>注意：<br>n在同一个方向重复上一次搜索命令<br>N在反方向重复上一次搜索命令<br>n(N)来源于next</p>
<p>注意：<br>在/pattern之前先跳到第一行则进行全文件搜索。</p>
<p>:%s/p1/p2/g将文件中所有的p1均用p2替换<br>:%s/p1/p2/gc替换时需要确认</p>
<p>s:substitute替换<br>g:global全局<br>c:confirm确认</p>
<p>vi的难点：<br>1）vi操作之前，先判断一下当前是哪一种模式，再看光标所在位置。<br>当你不知道处于何种模式时，使用esc键返回到一般模式。<br>再看光标，难点在于移动光标，可以做到快速切换到某一行某一列。</p>
<p>vi编辑器有三种模式<br>1）一般模式（光标移动、复制、粘贴、删除、撤销）<br>   hjkl、ngg/G、0、$、fx<br>   yy/nyy<br>   p<br>   dd/ndd、x<br>   u<br>2）编辑模式（编辑文本）<br>   i  a o<br>3）命令行模式（查找和替换、保存退出文件）<br>   /pattern、:%s/p1/p2/gc、:wq</p>
<p>举例：<br>1）用vi 新建一个文件test2.txt，然后输入”welaome to the world of vi.”,并保存。<br>2）由于拼写错误，需要将其中的welaome中的a替换成c。<br>3）在上步的基础上，复制第一行到第二行和第三行。<br>4）在上步的基础上，删除第三行的全部内容。<br>5）在上步的基础上，搜索出现vi的地方。<br>6）在上步的基础上，将字符串vi替换成vim。<br>7）保存并退出。</p>
<h1 id="vi常用命令汇总表"><a href="#vi常用命令汇总表" class="headerlink" title="vi常用命令汇总表"></a><strong>vi常用命令汇总表</strong></h1><table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">命令及作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>打开文件</strong></td>
<td align="left">vi+文件名/vi+文件名+行号</td>
</tr>
<tr>
<td align="left"><strong>退出/保存文件</strong></td>
<td align="left">:q! 强制退出vi,即使文件被修改，也不保存</td>
</tr>
<tr>
<td align="left"><strong>进入编辑模式</strong></td>
<td align="left">:wq 保存文件并退出</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">:w 保存文件</td>
</tr>
<tr>
<td align="left"><strong>进入编辑模式</strong></td>
<td align="left"><em>i 在光标前开始插入文本</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>a 在光标后开始插入文本</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>o 在当前行之下新开一行</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>O 在当前行之上新开一行</em></td>
</tr>
<tr>
<td align="left"><strong>光标移动（多行间切换）</strong></td>
<td align="left">Ctrl+f 向前滚动一整屏</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Ctrl+b 向后滚动一整屏</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">gg 转至文件开头</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">G 转至文件结尾</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">ngg/nG 光标移至第n行的行首（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">:n 光标移动至第n行的行首（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">n+ 光标向下移动n行（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">n- 光标向上移动n行（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">j/nj 光标向下移动1行/n行（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">k/nk 光标向上移动1行/n行（n为数字）</td>
</tr>
<tr>
<td align="left"><strong>光标移动（单行间切换）</strong></td>
<td align="left">0 （数字零）光标移至当前行行首</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">$ 光标移至当前行行末</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">h/nh 光标向左移动1列/n列（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">k/nk 光标向右移动1列/n列（n为数字）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">w 光标移动到下一个字的开头</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">b 光标移动到上一个字的开头</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">fx 搜索当前行中下一个出现字母x的地方</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Fx 搜索当前行中上一个出现字母x的地方</td>
</tr>
<tr>
<td align="left"><strong>文本复制命令</strong></td>
<td align="left"><em>yy 复制当前行</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>nyy 复制当前行及其后的n-1行</em></td>
</tr>
<tr>
<td align="left"><strong>文本删除命令</strong></td>
<td align="left"><em>x 删除光标后的一个字符</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">X 删除光标前的一个字符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">nx 删除光标后的n个字符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">nX 删除光标前的n个字符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">dw 从光标处删至当前词尾</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">db 从光标处删至当前词首</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">d0 从光标处删至行首</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">d$/D 从光标处删至行尾</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>dd  删除光标所在行</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>ndd 删除当前行及其后的n-1行</em></td>
</tr>
<tr>
<td align="left"><strong>文本粘贴命令</strong></td>
<td align="left"><em>使用P键</em></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">如复制当前行，先用yy复制当前行，切换到目的行的上一行后，用p来粘贴所复制的行。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">如剪切当前行，先用dd复制当前行，切换到目的行的上一行后，用p来粘贴所剪切的行。</td>
</tr>
<tr>
<td align="left"><strong>撤销命令</strong></td>
<td align="left"><em>按u键来撤销上一步操作</em></td>
</tr>
<tr>
<td align="left"><strong>查找及替换命令</strong></td>
<td align="left"><em>/pattern 从光标开始处向文件尾搜索pattern</em>（在/pattern之前先跳到第一行则进行全文件搜索），后按下n或N</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">?pattern 从光标开始处向文件首部搜索pattern ，后按下n或N</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">注：n在同一个方向重复上一次搜索命令,N在反方向重复上一次搜索命令</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">:s/p1/p2/g将当前行中所有的p1均用p2替换，:s/p1/p2/gc替换时需要确认</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">:n1,n2s/p1/p2/g将n1至n2行中所有的p1均用p2替换，:n1,n2s/p1/p2/gc替换时需要确认</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>:%s/p1/p2/g将文件中所有的p1均用p2替换，:%s/p1/p2/gc替换时需要确认</em></td>
</tr>
</tbody></table>
<p>更正：</p>
<p>x删除光标所在位置的字符</p>
<p>nx删除光标所在位置和光标后的n-1个字符</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Modbus1-modbus协议分析</title>
    <url>/2020/02/17/Modbus1-modbus%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1-范围"><a href="#1-1-范围" class="headerlink" title="1.1 范围"></a>1.1 范围</h3><p>MODBUS 是 OSI 模型第 7 层上的应用层报文传输协议，它在连接至不同类型总线或网络的设备之间提供客户机/服务器通信。<br>自从 1979 年出现工业串行链路的事实标准以来，MODBUS 使成千上万的自动化设备能够通信。<br>目前，继续增加对简单而雅观的 MODBUS 结构支持。互联网组织能够使 TCP/IP 栈上的保留系统端口 502 访问MODBUS。<br>MODBUS 是一个请求/应答协议，并且提供功能码规定的服务。MODBUS 功能码是 MODBUS请求/应答 PDU 的元素。本文件的作用是描述 MODBUS 事务处理框架内使用的功能码。</p>
<h3 id="1-2规范性引用文件"><a href="#1-2规范性引用文件" class="headerlink" title="1.2规范性引用文件"></a>1.2规范性引用文件</h3><p>1．RFC791，互联网协议，Sep81 DARPA<br>2．MODBUS 协议参考指南 Rev J,MODICON，1996 年 6 月，doc#PI_MBUS_300<br>MODBUS 是一项应用层报文传输协议，用于在通过不同类型的总线或网络连接的设备之间的客户机/服务器通信。<br>目前，使用下列情况实现 MODBUS：<br>以太网上的 TCP/IP。<br>各种媒体（有线：EIA/TIA-232-E、EIA-422、EIA/TIA-485-A；光纤、无线等等）上的异步串行传输。<br>MODBUS PLUS，一种高速令牌传递网络。<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/0A6964ABCFB740B0B1434B68C7F12090/2422" alt="picture"></p>
<h2 id="2、缩略语"><a href="#2、缩略语" class="headerlink" title="2、缩略语"></a>2、缩略语</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADU 	应用数据单元</span><br><span class="line">HDLC 	高级数据链路控制</span><br><span class="line">HMI 	人机界面</span><br><span class="line">IETF	因特网工程工作组</span><br><span class="line">I/O 	输入/输出设备</span><br><span class="line">IP 		互连网协议</span><br><span class="line">MAC	    介质访问控制</span><br><span class="line">MB 	    MODBUS 协议</span><br><span class="line">MBAP    MODBUS 协议</span><br><span class="line">PDU     协议数据单元</span><br><span class="line">PLC	    可编程逻辑控制器</span><br><span class="line">TCP     传输控制协议</span><br></pre></td></tr></table></figure>

<h2 id="3、背景概要"><a href="#3、背景概要" class="headerlink" title="3、背景概要"></a>3、背景概要</h2><p>  MODBUS 协议允许在各种网络体系结构内进行简单通信。  </p>
<p><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/0A6964ABCFB740B0B1434B68C7F12090/2422" alt="picture"></p>
<p>  每种设备（PLC、HMI、控制面板、驱动程序、动作控制、输入/输出设备）都能使用 MODBUS协议来启动远程操作。</p>
<p>  在基于串行链路和以太 TCP/IP 网络的 MODBUS 上可以进行相同通信。</p>
<p>  一些网关允许在几种使用 MODBUS 协议的总线或网络之间进行通信。  </p>
<h2 id="4、总体描述"><a href="#4、总体描述" class="headerlink" title="4、总体描述"></a>4、总体描述</h2><h3 id="4-1-协议描述"><a href="#4-1-协议描述" class="headerlink" title="4.1 协议描述"></a>4.1 协议描述</h3><p>  MODBUS 协议定义了一个与基础通信层无关的简单协议数据单元（PDU）。特定总线或网络上的 MODBUS 协议映射能够在应用数据单元（ADU）上引入一些附加域。  </p>
<p> <img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/2371EEE1EFA542AC889C4DF395764A95/2427" alt="img"> </p>
<p>启动 MODBUS 事务处理的客户机创建 MODBUS 应用数据单元。功能码向服务器指示将执行哪种操作。  </p>
<p>MODBUS 协议建立了客户机启动的请求格式。  </p>
<p>用一个字节编码 MODBUS 数据单元的功能码域。有效的码字范围是十进制 1-255（128-255 为  异常响应保留）。当从客户机向服务器设备发送报文时，功能码域通知服务器执行哪种操作。</p>
<p>向一些功能码加入子功能码来定义多项操作。<br>从客户机向服务器设备发送的报文数据域包括附加信息，服务器使用这个信息执行功能码定义  的操作。这个域还包括离散项目和寄存器地址、处理的项目数量以及域中的实际数据字节数。<br>在某种请求中，数据域可以是不存在的（0 长度），在此情况下服务器不需要任何附加信息。功能码仅说明操作。<br>如果在一个正确接收的 MODBUS ADU 中，不出现与请求 MODBUS 功能有关的差错，那么服<br>务器至客户机的响应数据域包括请求数据。如果出现与请求 MODBUS 功能有关的差错，那么域包括一个异常码，服务器应用能够使用这个域确定下一个执行的操作。<br>例如，客户机能够读一组离散量输出或输入的开/关状态，或者客户机能够读/写一组寄存器的数据内容。<br>当服务器对客户机响应时，它使用功能码域来指示正常（无差错）响应或者出现某种差错（称为异常响应）。对于一个正常响应来说，服务器仅对原始功能码响应。<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/28DF4966200D413B87E15ABCFFEEAA49/2429" alt="img"><br>对于异常响应，服务器返回一个与原始功能码等同的码，设置该原始功能码的最高有效位为逻辑 1。  </p>
<p><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/EF0936A44DD84FCFB539A9FDB99691CC/2431" alt="img"><br><strong>注释：</strong>需要管理超时，以便明确地等待可能不会出现的应答。<br>串行链路上第一个 MODBUS 执行的长度约束限制了 MODBUS PDU 大小（最大 RS485ADU=256字节）。<br>因此，对串行链路通信来说，MODBUS PDU=256-服务器地址（1 字节）-CRC（2 字节）＝253字节。<br>RS232 / RS485 ADU = 253 字节+服务器地址(1 byte) + CRC (2 字节) = 256 字节。<br>TCP MODBUS ADU = 249 字节+ MBAP (7 字节) = 256 字节。<br>MODBUS 协议定义了三种 PDU。它们是：<br><em>MODBUS 请求 PDU，mb_req_pdu</em><br><em>MODBUS 响应 PDU，mb_rsp_pdu</em><br><em>MODBUS 异常响应 PDU，mb_excep_rsp_pdu</em></p>
<p>定义 mb_req_pdu 为：<br>mb_req_pdu = { function_code, request_data}，其中function_code - [1 个字节] MODBUS 功能码<br>mb_req_pdu = { function_code, request_data}，其中function_code - [1 个字节] MODBUS 功能码量、子功能码等信息。</p>
<p>定义 mb_rsp_pdu 为：<br>mb_rsp_pdu = { function_code, response_ data}，其中<br>function_code - [1 个字节] MODBUS 功能码<br>response_data - [n 个字节]，这个域与功能码有关，并且通常包括诸如可变参考、变量、数据偏移量、子功能码等信息。</p>
<p>定义 mb_excep_rsp_pdu 为：<br>mb_excep_rsp_pdu = { function_code, request_data}，其中<br>function_code - [1 个字节] MODBUS 功能码 + 0x80<br>exception_code - [1 个字节]，在下表中定义了 MODBUS 异常码。</p>
<h3 id="4-2-数据编码"><a href="#4-2-数据编码" class="headerlink" title="4.2 数据编码"></a>4.2 数据编码</h3><p>MODBUS 使用一个‘big-Endian’ 表示地址和数据项。这意味着当发射多个字节时，首先发送最高有效位。例如：<br>    <u>寄存器大小        值</u></p>
<p>  16 – 比特        0x1234        发送的第一字节为     0x12    然后 0x34  </p>
<h3 id="4-3-MODBUS数据模型"><a href="#4-3-MODBUS数据模型" class="headerlink" title="4.3 MODBUS数据模型"></a>4.3 MODBUS数据模型</h3><p>MODBUS 以一系列具有不同特征表格上的数据模型为基础。四个基本表格为：<br>| 基本表格 | 对象类型 | 访问类型 | 内容 |<br>| :—–| :—-: | :—-: | :—-: |<br>| <strong>离散量输入</strong> | 单个比特 | 只读 | I/O 系统提供这种类型数据 |<br>| <strong>线圈</strong> | 单个比特 | 读写 | 通过应用程序改变这种类型数据 |<br>| <strong>输入寄存器</strong> | 16-比特字 | 只读 | I/O 系统提供这种类型数据 |<br>| <strong>保持寄存器</strong> | 16-比特字 | 读写 | 通过应用程序改变这种类型数据 |</p>
<p>  输入与输出之间以及比特寻址的和字寻址的数据项之间的区别并没有暗示任何应用操作。如果这是对可疑对象核心部分最自然的解释，那么这种区别是可完全接受的，而且很普通，以便认为四个表格全部覆盖了另外一个表格。 </p>
<p> 对于基本表格中任何一项，协议都允许单个地选择 65536 个数据项，而且设计那些项的读写操作可以越过多个连续数据项直到数据大小规格限制，这个数据大小规格限制与事务处理功能码有关。很显然，必须将通过 MODBUS 处理的所有数据放置在设备应用存储器中。但是，存储器的物理地址不应该与数据参考混淆。要求仅仅是数据参考与物理地址的链接。</p>
<p>MODBUS 功能码中使用的 MODBUS 逻辑参考数字是以 0 开始的无符号整数索引。<br>MODBUS 模型实现的实例<br>下例实例示出了两种在设备中构造数据的方法。可能有不同的结构，这个文件中没有全部描述出来。每个设备根据其应用都有它自己的数据结构。<br><strong>实例 1：有 4 个独立块的设备</strong><br>下例实例示出了设备中的数据结构，这个设备含有数字量和模拟量、输入量和输出量。由于不同块中的数据不相关，每个块是相互独立。按不同 MODBUS 功能码访问每个块。<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/5D5E85E04EF345ACA518F43389CA6788/2439" alt="img"><br><strong>实例 2：仅有 1 个块的设备</strong><br>在这个实例中，设备仅有 1 个数据块。通过几个 MODBUS 功能码可能得到一个相同数据，或者通过 16 比特访问或 1 个访问比特。<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/A1CA82F95175410E8D21F74834084BBF/2436" alt="img"></p>
<h3 id="4-3-MODBUS-事务处理的定义"><a href="#4-3-MODBUS-事务处理的定义" class="headerlink" title="4.3 MODBUS 事务处理的定义"></a>4.3 MODBUS 事务处理的定义</h3><p>下列状态图描述了在服务器侧 MODBUS 事务处理的一般处理过程。<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/C0F92039AA914ECF9B09A41115FE73EE/2441" alt="img"></p>
<p>  一旦服务器处理请求，使用合适的 MODBUS 服务器事务建立 MODBUS 响应。<br>  根据处理结果，可以建立两种类型响应：<br>  一个正 MODBUS 响应：<br><em>响应功能码 = 请求功能码  *<br>一个 MODBUS 异常响应(参见第 6.14 节)：<br>*用来为客户机提供处理过程中与被发现的差错相关的信息;</em><br><em>响应功能码 = 请求功能码 + 0x80；</em><br><em>提供一个异常码来指示差错原因。</em></p>
<h2 id="5、功能码分类"><a href="#5、功能码分类" class="headerlink" title="5、功能码分类"></a>5、功能码分类</h2><pre><code>有三类 MODBUS 功能码。它们是：</code></pre><p><strong>公共功能码</strong><br>    <em>是较好地被定义的功能码，</em><br>    <em>保证是唯一的，</em><br>    <em>MODBUS 组织可改变的，</em><br>    <em>公开证明的，</em><br>    <em>具有可用的一致性测试，</em><br>    <em>MB IETF RFC 中证明的，</em><br>    <em>包含已被定义的公共指配功能码和未来使用的未指配保留供功能码。</em><br><strong>用户定义功能码</strong><br>    <em>有两个用户定义功能码的定义范围，即 65 至 72 和十进制 100 至 110。</em><br>    <em>用户没有 MODBUS 组织的任何批准就可以选择和实现一个功能码</em><br>    <em>不能保证被选功能码的使用是唯一的。</em><br>    <em>如果用户要重新设置功能作为一个公共功能码，那么用户必须启动 RFC，以便将改变引入公共分类中，并且指配一个新的公共功能码。</em></p>
<p><strong>保留功能码</strong><br>    <em>一些公司对传统产品通常使用的功能码，并且对公共使用是无效的功能码。</em><br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/E0CBA29A1F924C4080D78EC42FAA374D/2443" alt="img"></p>
<h3 id="5-1公共功能码定义"><a href="#5-1公共功能码定义" class="headerlink" title="5.1公共功能码定义"></a>5.1公共功能码定义</h3><p><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/06EFDA58E07C4A8EBA86B6752864D2CC/2445" alt="img"></p>
<h2 id="6、功能码描述"><a href="#6、功能码描述" class="headerlink" title="6、功能码描述"></a>6、功能码描述</h2><h3 id="6-1-01-0x01-读线圈"><a href="#6-1-01-0x01-读线圈" class="headerlink" title="6.1 01 (0x01)读线圈"></a>6.1 01 (0x01)读线圈</h3><p>在一个远程设备中，使用该功能码读取线圈的 1 至 2000 连续状态。请求 PDU 详细说明了起始地址，即指定的第一个线圈地址和线圈编号。从零开始寻址线圈。因此寻址线圈 1-16 为 0-15。<br>根据数据域的每个比特将响应报文中的线圈分成为一个线圈。指示状态为 1= ON 和 0= OFF。第一个数据字节的 LSB（最低有效位）包括在询问中寻址的输出。其它线圈依次类推，一直到这个字节的高位端为止，并在后续字节中从低位到高位的顺序。<br>如果返回的输出数量不是八的倍数，将用零填充最后数据字节中的剩余比特（一直到字节的高位端）。字节数量域说明了数据的完整字节数。<br><strong>请求PDU</strong><br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/9979FB72F5354F83BC7FEAFBD899E66C/2452" alt="img"><br><strong>响应PDU</strong><br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/3121D1376C784C2283B18AE2AB252268/2449" alt="img"><br><em>N＝输出数量/8，如果余数不等于 0，那么 N = N+1<br>*</em>错误**<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/780818F9ED26436499B25A9BE46DCE7E/2454" alt="img"></p>
<p>这是一个请求读离散量输出 20-38 的实例：<br><img src="https://note.youdao.com/yws/public/resource/86101c74995dfe9b994f5b4ded7a0a42/xmlnote/B4A983D8D5DD4131A743EC9466CC3D08/2459" alt="img"><br>将输出 27-20 的状态表示为十六进制字节值 CD，或二进制 1100 1101。输出 27 是这个字节的MSB，输出 20 是 LSB。<br>通常，将一个字节内的比特表示为 MSB 位于左侧，LSB 位于右侧。第一字节的输出从左至右为 27 至 20。下一个字节的输出从左到右为 35 至 28。当串行发射比特时，从 LSB 向 MSB 传输：20 . . .27、28 . . . 35 等等。<br>在最后的数据字节中，将输出状态 38-36 表示为十六进制字节值 05，或二进制 0000 0101。输出<br>38 是左侧第六个比特位置，输出 36 是这个字节的 LSB。用零填充五个剩余高位比特。<br><strong>注:</strong> 用零填充五个剩余比特（一直到高位端）。</p>
<p><img src="https://note.youdao.com/ynoteshare1/images/replace-img.png" alt="img"></p>
<h3 id="02-0x02-读离散量输入"><a href="#02-0x02-读离散量输入" class="headerlink" title="02 (0x02)读离散量输入"></a>02 (0x02)读离散量输入</h3><p>在一个远程设备中，使用该功能码读取离散量输入的 1 至 2000 连续状态。请求 PDU 详细说明了起始地址，即指定的第一个输入地址和输入编号。从零开始寻址输入。因此寻址输入 1-16 为 0-15。<br>根据数据域的每个比特将响应报文中的离散量输入分成为一个输入。指示状态为 1= ON 和 0=OFF。第一个数据字节的 LSB（最低有效位）包括在询问中寻址的输入。其它输入依次类推，一直到这个字节的高位端为止，并在后续字节中从低位到高位的顺序。<br>如果返回的输入数量不是八的倍数，将用零填充最后数据字节中的剩余比特（一直到字节的高位端）。字节数量域说明了数据的完整字节数。</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>C-回调函数</title>
    <url>/2020/02/16/C-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="回调函数-Callback-Functions"><a href="#回调函数-Callback-Functions" class="headerlink" title="回调函数(Callback Functions)"></a>回调函数(Callback Functions)</h1><p>回调函数就是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。<em>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，</em>用于对该事件或条件进行响应。</p>
<p> 来自Stack Overflow某位大神简洁明了的表述：A “callback” is any function that is called  by another function which takes the first function as a parameter。  也就是说，函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2  执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3  就是回调函数。到此应该明白回调函数的定义了吧？ </p>
<h2 id="使用回调函数的好处"><a href="#使用回调函数的好处" class="headerlink" title="使用回调函数的好处"></a>使用回调函数的好处</h2><p>回掉函数的好处和作用，那就是解耦，就是因为这个特点，普通函数代替不了回调函数。所以，在我眼里，这才是回调函数最大的特点。来看看维基百科上面我觉得画得很好的一张图片。</p>
<hr>
<p><img src="https://note.youdao.com/yws/public/resource/f4e293235c7a6ddd037871d998546bd5/xmlnote/32FB209DB50A4AA590B0C69188B99639/2417%22" alt="PICTURE 图标" title="PICTURE"></p>
<p><strong>C语言代码举例说明以上图片</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;softwareLib.h&gt; // 包含Library Function所在读得Software library库的头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback</span><span class="params">()</span> <span class="comment">// Callback Function</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// Main program</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	Library(Callback);</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>乍一看，回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现两者之间的一个关键的不同：在回调中，主程序把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，这样有没有觉得很灵活？并且丝毫不需要修改库函数的实现，这就是解耦。再仔细看看，主函数和回调函数是在同一层的，而库函数在另外一层，想一想，如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了，这也就是在日常工作中常见的况。现在再把main()、Library()和Callback()函数套回前面 F1、F2和F3函数里面，是不是就更明白了？</em></p>
<h2 id="怎么使用回调函数？"><a href="#怎么使用回调函数？" class="headerlink" title="怎么使用回调函数？"></a>怎么使用回调函数？</h2><p><strong>举例如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">()</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_1 "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_2</span><span class="params">()</span> <span class="comment">// Callback Function 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_2 "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_3</span><span class="params">()</span> <span class="comment">// Callback Function 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_3 "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> (*Callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Handle Function. "</span>);</span><br><span class="line">    Callback();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Handle Function. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Main Function. "</span>);</span><br><span class="line">    Handle(Callback_1);</span><br><span class="line">    Handle(Callback_2);</span><br><span class="line">    Handle(Callback_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Main Function. "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entering Main Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_1</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_2</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_3</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Leaving Main Function.</span><br></pre></td></tr></table></figure>

<hr>
<p><em>可以看到，Handle()函数里面的参数是一个指针，在main()函数里调用Handle()函数的时候，给它传入了函数Callback_1()/Callback_2()/Callback_3()的函数名，这时候的函数名就是对应函数的指针，也就是说，回调函数其实就是函数指针的一种用法。现在再读一遍这句话：A “callback” is any function that is called by another function which  takes the first function as a parameter，是不是就更明白了呢？</em></p>
<h2 id="带参数的回调函数的使用"><a href="#带参数的回调函数的使用" class="headerlink" title="带参数的回调函数的使用"></a>带参数的回调函数的使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_1: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_2: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_3: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> (*Callback)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Handle Function. "</span>);</span><br><span class="line">    Callback(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Handle Function. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Main Function. "</span>);</span><br><span class="line">    Handle(a, Callback_1);</span><br><span class="line">    Handle(b, Callback_2);</span><br><span class="line">    Handle(c, Callback_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Main Function. "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entering Main Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_1: x = 2</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_2: x = 4</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_3: x = 6</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Leaving Main Function.</span><br></pre></td></tr></table></figure>

<hr>
<p><em>可以看到，并不是直接把int Handle(int (<em>Callback)()) 改成 int Handle(int (</em>Callback)(int)) 就可以的，而是通过另外增加一个参数来保存回调函数的参数值，像这里 int Handle(int y, int (*Callback)(int)) 的参数 y。同理，可以使用多个参数的回调函数。</em></p>
<hr>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux6-GNU汇编语法</title>
    <url>/2020/02/05/Linux6-GNU%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="GNU汇编"><a href="#GNU汇编" class="headerlink" title="GNU汇编"></a>GNU汇编</h1><p>GNU 汇编语法适用于所有的架构，并不是 ARM 独享的， GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label: instruction @ comment</span><br></pre></td></tr></table></figure>

<p><strong><em>lavel</em></strong> 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令单的地址，标号也可以用来表示数据地址。注意label后面的冒号“：”，任何以冒号“：”结尾的标识符都会被认识是一个标号。</p>
<p><strong><em>instruction</em></strong> 即指令，也就是汇编指令或伪指令。</p>
<p><strong><em>@</em></strong> 标号，表示后面是注释，就跟C语言里面的“/*   */“一样，其实在GNU汇编文件中我们可以使用同样的来进行注释。</p>
<p><strong><em>comment</em></strong> 就是注释内容。</p>
<p>比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">	MOVS R0,#0X12 @设置 R0=0X12</span><br></pre></td></tr></table></figure>

<p>  上面代码中“add:”就是标号，“MOVS R0,#0X12”就是指令，最后的“@设置 R0=0X12”就是注释。</p>
<p> <em>**注意！</em> **ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。  </p>
<p>用户可以使用.section伪操作来定义一个段，汇编系统预定义了一些段名:</p>
<p><strong><em>.text</em></strong> 表示代码段。</p>
<p><strong><em>.data</em></strong> 初始化的数据段。</p>
<p><strong><em>.bss</em></strong> 为初始化的数据段。</p>
<p><strong><em>.rodata</em></strong> 只读数据段。</p>
<p>​    我们当然可以自己使用.section来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.section .testsection @定义一个testsection段</span><br></pre></td></tr></table></figure>

<p>汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用ENTRY来指明其它 的入口点，下面的代码就是使用_start 作为入口标号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start</span><br><span class="line">	ldr r0, =0x12 @r0=0x12</span><br></pre></td></tr></table></figure>

<p>上面代码中.global是伪操作，表示_start是一个全局标号，类似C语言里面的全局变量一样，常见的伪操作有：<br><strong><em>.byte</em></strong> 定义单字节数据，比如.byte 0x12。<br><strong><em>.short</em></strong> 定义双字节数据，比如.byte 0x1234。<br><strong><em>.long</em></strong> 定义一个4字节数据，比如.long 0x12345678。<br><strong><em>.equ</em></strong> 赋值语句，格式为： .equ 变量名，表达式，比如.equ num,0x12，表示 num = 0x12。<br><strong><em>.align</em></strong> 数据字节对齐，比如：.align 4表示4字节对齐。<br><strong><em>.end</em></strong> 表示源文件结束。<br><strong><em>.global</em></strong> 定义一个全局符号，格式为： .global symbol, 比如： .global _start</p>
<h2 id="GNU-汇编同样也支持函数，函数格式如下："><a href="#GNU-汇编同样也支持函数，函数格式如下：" class="headerlink" title="GNU 汇编同样也支持函数，函数格式如下："></a>GNU 汇编同样也支持函数，函数格式如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名：</span><br><span class="line">	函数体</span><br><span class="line">	返回语句</span><br></pre></td></tr></table></figure>

<p>GNU汇编函数返回语句不是必须的，如下代码就是用汇编写的Cortex-A7中断服务函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 未定义中断 */</span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, = Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line">	</span><br><span class="line">/* SVC中断 */</span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line">	</span><br><span class="line">/* 预取终止中断 */</span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>

<p>上述代码中定义了三个汇编函数： Undefined_Handler、 SVC_Handler 和PrefAbort_Handler。以函数 Undefined_Handler 为例我们来看一下汇编函数组成，“Undefined_Handler”就是函数名，“ldr r0, =Undefined_Handler”是函数体，“bx r0”是函数返回语句，“bx”指令是返回指令，函数返回语句不是必须的。</p>
<h1 id="Cortex-A7常用汇编指令"><a href="#Cortex-A7常用汇编指令" class="headerlink" title="Cortex-A7常用汇编指令"></a>Cortex-A7常用汇编指令</h1><p>所有汇编指令请参考《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf》的 A4章节。</p>
<h2 id="1-处理器内部数据传输指令"><a href="#1-处理器内部数据传输指令" class="headerlink" title="1.处理器内部数据传输指令"></a>1.处理器内部数据传输指令</h2><p>使用处理器做的最多的事情就是在树立起内部来回的传递数据，常见的操作有：</p>
]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux5-挂载NFS网络文件系统</title>
    <url>/2020/02/01/Linux5-%E6%8C%82%E8%BD%BDNFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-挂载NFS网络文件系统"><a href="#1-挂载NFS网络文件系统" class="headerlink" title="1.挂载NFS网络文件系统"></a>1.挂载NFS网络文件系统</h1><p>挂载NFS网络文件系统，为主机与arm Linux应用传输到开发板做准备。</p>
<h2 id="1-1-网络文件系统简介"><a href="#1-1-网络文件系统简介" class="headerlink" title="1.1 网络文件系统简介"></a>1.1 网络文件系统简介</h2><p>网络文件系统，通常称为NFS(Network File System),它是一种非常便捷的在服务器与客户端通过网络共享文件的方式,具体如下图。<br><img src="https://tutorial.linux.doc.embedfire.com/zh_CN/latest/_images/mountn002.png" alt="avatar"></p>
]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Philosophy_亚瑟阿伦的36个问题(人际沟通交流)</title>
    <url>/2020/01/29/Philosophy-%E4%BA%9A%E7%91%9F%E9%98%BF%E4%BC%A6%E7%9A%8436%E4%B8%AA%E9%97%AE%E9%A2%98-%E4%BA%BA%E9%99%85%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>BC95_AT_指令</title>
    <url>/2020/01/01/BC95_AT_%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-3GPP命令"><a href="#1-3GPP命令" class="headerlink" title="1.   3GPP命令"></a>1.   3GPP命令</h1><h2 id="1-1-显示产品详细信息命令"><a href="#1-1-显示产品详细信息命令" class="headerlink" title="1.1 显示产品详细信息命令"></a>1.1 显示产品详细信息命令</h2><p><strong>ATI</strong> </p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ATI</span><br><span class="line">Quectel</span><br><span class="line">BC95-B5</span><br><span class="line">Revision:BC95B5HBR01A02W16</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="1-2-打开关闭命令回显"><a href="#1-2-打开关闭命令回显" class="headerlink" title="1.2 打开关闭命令回显"></a>1.2 打开关闭命令回显</h2><p><strong>ATE</strong></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ATE0</span><br><span class="line">OK</span><br><span class="line">ATI</span><br><span class="line">Quectel</span><br><span class="line">BC95-B5</span><br><span class="line">Revision:BC95B5HBR01A02W16</span><br><span class="line">OK</span><br><span class="line">ATE1</span><br><span class="line">OK</span><br><span class="line">ATI</span><br><span class="line">ATI</span><br><span class="line">Quectel</span><br><span class="line">BC95-B5</span><br><span class="line">Revision:BC95B5HBR01A02W16</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NBIOT</category>
      </categories>
      <tags>
        <tag>BC95</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux4-VIM文本编辑器的安装及使用</title>
    <url>/2019/11/26/Linux4-VIM%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="VI-VIM编辑器"><a href="#VI-VIM编辑器" class="headerlink" title="VI/VIM编辑器"></a>VI/VIM编辑器</h1><p>在Ubuntu终端模式下进行文本编辑功能建议使用VI/VIM编辑器，Ubuntu系统自带VI编辑器，但是 VI 编辑器对于习惯了 Windows 下进行开发的人来说不方便，比如竟然不能使用键盘上的上下左右键调整光标位置。因此我推荐大家使用 VIM 编辑器， VIM 编辑器是 VI 编辑器升级版本， VI/VIM 编辑器都是一种基于指令式的编辑器，不需要鼠标，也没有菜单，仅仅使用键盘来完成所有的编辑工作。</p>
<p><strong>安装VIM编辑器，命令如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>

<p>安装完成以后就可以使用 VIM 编辑器了， VIM 编辑器有 3 种工作模式：输入模式、指令模式和底行模式，通过切换不同的模式可以完成不同的功能，我们就以编辑一个文本文档为例讲解 VIM 编辑器的使用。</p>
<p><em>例如：使用vim编辑器打开test.txt文档</em></p>
<p><em>输入命令：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim test.txt</span><br></pre></td></tr></table></figure>

<p><em>默认打开时，无法直接输入这不是键盘问题。由于VIM默认是在只读模式打开文档的，因此我们需要切换到输入模式，切换到输入模式的命令如下：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i	在当前光标所在字符的前面，转为输入模式；</span><br><span class="line">I	在当前光标所在行的行首转换为输入模式；</span><br><span class="line">a	在当前光标所在字符后面，转为输入模式；</span><br><span class="line">A	在当前光标所在行行尾，转换为输入模式；</span><br><span class="line">o	在当前光标所在行的下方，新建一行，并转换为输入模式；</span><br><span class="line">O	在当前光标所在行的上方，新建一行，并转换为输入模式；</span><br><span class="line">s	删除光标所在字符；</span><br><span class="line">r	替换光标处字符。</span><br></pre></td></tr></table></figure>

<p><em>最常用的输入命令就是”a”，在输入a以后在编辑下的左下方就会显示“出入等字样”。</em></p>
<p>在txt文档我们输入完成以后需要保存文本啊， Windows 下的记事本可以使用快捷键 Ctrl+S 来保存， VIM 是否也可以使用 Ctrl+S 来保存呢？你会发现当你按下 Ctrl+S 键以后你的终端不能操作了！！！这是因为在 Ubuntu 下 Ctrl+S 快捷键不是用来完成保存的功能的，而是暂停该终端！所以你一旦在使用终端的时候按下 Ctrl+S快捷键，那么你的终端肯定不会再有任何反应，如果你按下 Ctrl+S 关闭了当前终端的话可以按下 Ctrl+Q 来重新打开终端。既然 Ctrl+S 不能保存文本文档，那么有没有其它方法保存文本文档呢？肯定是有的，我们需要从 VIM 现在的输入模式切换到指令模式，方式就是按下键盘的 ESC 键，按下 ESC 键以后终端坐下角的“插入”字样就会消失，此时你就不能在输入任何文本了，如果想再次输入文本的话就按下“a”键重新进入到输入模式。 </p>
<p><em>指令模式顾名思义就是输入指令的模式，这些指令是 控制文本的指令，我们将这些指令进行分类，如下所示：</em></p>
<p><strong>1、移动光标指令：</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">h(左方向键)	光标左移一个字符；</span><br><span class="line">l(右方向键) 光标右移一个字符;</span><br><span class="line"><span class="keyword">j</span>(下方向键)	光标下移一行；</span><br><span class="line"><span class="keyword">k</span>(上方向键)	光标上移一行；</span><br><span class="line"></span><br><span class="line">nG		光标移动到第n行首；</span><br><span class="line">n+		光标下移n行；</span><br><span class="line">n-		光标上移n行。</span><br></pre></td></tr></table></figure>

<p><strong>2、屏幕翻滚指令</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Ctrl+<span class="keyword">f</span>		屏幕向下翻一页，相当于下一页；</span><br><span class="line">Ctrl+<span class="keyword">b</span>		屏幕向上翻一页，相当于上一页。</span><br></pre></td></tr></table></figure>

<p><strong>3、复制、删除和粘贴指令</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cc</span>	删除整行，并且修改整行内容；</span><br><span class="line">dd	删除该行，比提供修改功能；</span><br><span class="line">ndd 删除当前行向下n行；</span><br><span class="line"><span class="keyword">x</span>	删除光标所在字符；</span><br><span class="line"><span class="keyword">X</span>	删除光标前面一个字符；</span><br><span class="line">nyy 复制当前行及下面n行；</span><br><span class="line"><span class="keyword">p</span>	粘贴最近复制的内容。</span><br></pre></td></tr></table></figure>

<p>上面就是 VI/VIM 的命令模式下最常用的一些命令，还有一些不常用的我没有列出来，感兴趣的可以自行上网查阅。从上面的命令可以看出，并没有保存文本的命令，那是因为保存文档的命令是在底行模式中，我们要先进入到指令模式，进入底行模式的方式是先进入指令模式下，然后在指令模式下输入“：”进入底行模式。</p>
<p><em>当进入底行模式以后会在终端的左下角就会出现符号“：”，我们可以在“：”<br>后面输入命令，常用的命令如下：</em></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">x</span>	保存当前文档并且推出；</span><br><span class="line">q	推出；</span><br><span class="line"><span class="keyword">w</span>	保存文档；</span><br><span class="line">q!	退出VI/VIM，不保存文档。</span><br></pre></td></tr></table></figure>

<p>如果我们要退出并保存文档的话需要在”:”底行模式下输入”wq”。</p>
<p>在“：”底行模式下输入“wq”以后按下回车键就保存 test.txt 并退出 VI/VIM 编辑器，退出以后我们可以使用命令“cat”来查看刚刚新建的 test.txt 文档的内容 。</p>
<p><em>在上面讲解进入 VIM 的底行模式的时候之说了在指令模式下输入“：”的方法，还可以在指令模式下输入“/”进入底行模式</em></p>
<p><em>在“/”底行模式下我们可以在文本中搜索指定的内容，比如搜索 test.txt 文件中“嵌入式”三个字，在“/”后面输入要搜索的内容，然后按下回车键就会在 test.txt 中找到与字符串“嵌入式”匹配的部分。</em><br><em>在 test.txt 中找到了“嵌入式”这个词，并且标记出来位置。我们以后要在一个文档中搜素是否存在某个字符串的时候就可以使用这种方法。有关 VI/VIM 编辑器的讲解就到这里，我们完整的练习了一遍如何使用 VIM 创建文档、编辑文档、保存文档和在文档中搜索字符串。</em></p>
<p>以上为Ubuntu下VI/VIM编辑器的基本使用命令和方法</p>
]]></content>
  </entry>
  <entry>
    <title>Linux3-Ubuntu下APT下载工具</title>
    <url>/2019/11/24/Linux3-Ubuntu%E4%B8%8BAPT%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="APT下载工具简介"><a href="#APT下载工具简介" class="headerlink" title="APT下载工具简介"></a>APT下载工具简介</h1><p>Ubuntu下我们常使用的下载工具就是：APT下载工具，APT 下载工具可以实现软件自动下载、配置、安装二进制或者源码的功能。 APT 下载工具和我们前面讲解的“install”命令结合在一起构成了 Ubuntu 下最常用的下载和安装软件方法。它解决了 Linux 平台下一安装软件的一个缺陷，即软件之间相互依赖。<br>APT 采用的 C/S 模式，也就是客户端/服务器模式，我们的 PC 机作为客户端，当需要下载软件的时候就向服务器请求，因此我们需要知道服务器的地址，也叫做安装源或者更新源。</p>
<h2 id="1-更新本地数据库"><a href="#1-更新本地数据库" class="headerlink" title="1.更新本地数据库"></a>1.更新本地数据库</h2><p>如果想查看本地哪些软件可以更新的话可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h2 id="2-检查依赖关系"><a href="#2-检查依赖关系" class="headerlink" title="2.检查依赖关系"></a>2.检查依赖关系</h2><p>有时候本地某些软件可能存在依赖关系，所谓依赖关系就是 A 软件依赖于 B 软件。通过如下命令可以查看依赖关系，如果存在依赖关系的话 APT 会提出解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get check</span><br></pre></td></tr></table></figure>

<h2 id="3-软件安装"><a href="#3-软件安装" class="headerlink" title="3.软件安装"></a>3.软件安装</h2><p>软件安装使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install package-name</span><br></pre></td></tr></table></figure>

<p>可以看出上述命令是由“apt-get”和“install”组合在一起的，“package-name”就是要安装的软件名字，“apt-get”负责下载软件，“install”负责安装软件。比如我们要安装软件 Ubuntu 下的串口工具“minicom”，我们就可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install minicom</span><br></pre></td></tr></table></figure>

<p>执行以上命令以后就会自动下载和安装minicom软件。</p>
<p>安装 minicom 这个软件的过程，会有如下所示询问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您希望继续执行吗？ [Y/n]</span><br></pre></td></tr></table></figure>

<p>如果希望继续执行的话就输入 y，如果不希望继续执行的话就输入 n。安装完成以后我们直接在终端输入如下命令打开 minicom 这个串口软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minicom -s</span><br></pre></td></tr></table></figure>

<p>关于 minicom 的使用大家可以上网搜索一下，这里就不详细讲解了，要退出 minicom 可以直接按下 ESC 键。</p>
<h2 id="4-软件更新"><a href="#4-软件更新" class="headerlink" title="4.软件更新"></a>4.软件更新</h2><p>更新软件的话使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade package-name</span><br></pre></td></tr></table></figure>

<p>其中 package-name 为要升级的软件名字，比如我们升级刚刚安装的 minicom 这个软件，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade minicom</span><br></pre></td></tr></table></figure>

<h2 id="5-卸载软件"><a href="#5-卸载软件" class="headerlink" title="5.卸载软件"></a>5.卸载软件</h2><p>卸载软件使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove package-name</span><br></pre></td></tr></table></figure>

<p>其中package-name是要卸载的软件，比如卸载前面安装的minicom软件。</p>
<p>以上为Ubuntu下的APT下载工具的大部分使用命令了。</p>
]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux2-Unbuntu常用命令</title>
    <url>/2019/11/24/Linux2-Unbuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Ubuntu系统操作基本命令"><a href="#Ubuntu系统操作基本命令" class="headerlink" title="Ubuntu系统操作基本命令"></a>Ubuntu系统操作基本命令</h1><h2 id="1-目录信息查看命令ls"><a href="#1-目录信息查看命令ls" class="headerlink" title="1.目录信息查看命令ls"></a>1.目录信息查看命令ls</h2><p>文件浏览是最基本的操作了， Shell 下文件浏览命令为 ls，格式如下：<br>ls    [选项]    [路径]<br>ls 命令主要用于显示指定目录下的内容，列出指定目录下包含的所有的文件以及子目录，<br>它的主要参数有：<br>-a 显示所有的文件以及子目录，包括以“.”开头的隐藏文件。<br>-l 显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。<br>-t 将文件按照创建时间排序列出。<br>-A 和-a 一样，但是不列出“.” (当前目录)和“..” (父目录)。<br>-R 递归列出所有文件，包括子目录中的文件。<br>Shell 命令里面的参数是可以组合在一起用的，比如组合“-al”就是显示所有文件的详细信<br>息，包括以“.”开头的隐藏文件， ls 命令使用如图 2.2.4.1 所示：</p>
<h2 id="2-目录切换命令-cd"><a href="#2-目录切换命令-cd" class="headerlink" title="2.目录切换命令 cd"></a>2.目录切换命令 cd</h2><p>要想在 Shell 中切换到其它的目录，使用的命令是 cd，命令格式如下：<br>cd [路径]<br>路径就是我们要进入的目录路径，比如下面所示操作：<br>cd / //进入到根目录“/”下， Linux 系统的根目录为“/” ,<br>cd /usr //进入到目录“/usr”里面。<br>cd .. //进入到上一级目录。<br>cd ~ //切换到当前用户主目录</p>
<h2 id="3-当前路径显示命令-pwd"><a href="#3-当前路径显示命令-pwd" class="headerlink" title="3.当前路径显示命令 pwd"></a>3.当前路径显示命令 pwd</h2><p>pwd 命令用来显示当前工作目录的绝对路径，不需要任何的参数</p>
<h2 id="4-系统信息查看命令-uname"><a href="#4-系统信息查看命令-uname" class="headerlink" title="4.系统信息查看命令 uname"></a>4.系统信息查看命令 uname</h2><p>要查看当前系统信息，可以使用命令 uname，命令格式如下：<br>uname [选项]<br>可选的选项参数如下：<br>-r 列出当前系统的具体内核版本号。<br>-s 列出系统内核名称。<br>-o 列出系统信息。</p>
<h2 id="5-清屏命令-clear"><a href="#5-清屏命令-clear" class="headerlink" title="5.清屏命令 clear"></a>5.清屏命令 clear</h2><p>clear 命令用于清除终端上的所有内容，只留下一行提示符</p>
<h2 id="6-切换用户执行身份命令-sudo"><a href="#6-切换用户执行身份命令-sudo" class="headerlink" title="6.切换用户执行身份命令 sudo"></a>6.切换用户执行身份命令 sudo</h2><p>Ubuntu(Linux)是一个允许多用户的操作系统，其中权限最大的就是超级用户 root，有时候<br>我们执行一些操作的时候是需要用 root 用户身份才能执行，比如安装软件。通过 sudo 命令可以<br>使我们暂时将身份切换到 root 用户。当使用 sudo 命令的时候是需要输入密码的，这里要注意输<br>入密码的时候是没有任何提示的！命令格式如下：<br>sudo [选项] [命令]<br>选项主要参数如下：<br>-h 显示帮助信息<br>l 列出当前用户可执行与不可执行的命令<br>-p 改变询问密码的提示符。<br>假如我们现在要创建一个新的用户 test，创建新用户的命令为“adduser”，创建新用户的权限只有 root 用户才有，我们在装系统的时候创建的那个用户是没有这个权限的.</p>
<h2 id="7-添加用户命令-adduser"><a href="#7-添加用户命令-adduser" class="headerlink" title="7.添加用户命令 adduser"></a>7.添加用户命令 adduser</h2><p>在讲解 sudo 命令的时候我们已经用过命令“adduser”，此命令需要 root 身份去运行。命令<br>格式如下：<br>adduser [参数] [用户名]<br>常用的参数如下：<br>-system 添加一个系统用户<br>-home DIR DIR 表示用户的主目录路径<br>-uid ID ID 表示用户的 uid。<br>-ingroup GRP 表示用户所属的组名。<br>adduser 的使用我们前面已经演示过了，大家可以试着再添加一个用户。</p>
<h2 id="8-删除用户命令-deluser"><a href="#8-删除用户命令-deluser" class="headerlink" title="8.删除用户命令 deluser"></a>8.删除用户命令 deluser</h2><p>前面讲了添加用户的命令，那肯定也有删除用户的命令，删除用户使用命令“deluser”，命<br>令参数如下：<br>deluser [参数] [用户名]<br>主要参数有：<br>-system 当用户是一个系统用户的时候才能删除。<br>-remove-home 删除用户的主目录<br>-remove-all-files 删除与用户有关的所有文件。<br>-backup 备份用户信息<br>同样的，命令“deluser”也要使用“sudo”来以 root 用户运行.</p>
<h2 id="9-切换用户-命令-su"><a href="#9-切换用户-命令-su" class="headerlink" title="9.切换用户 命令 su"></a>9.切换用户 命令 su</h2><p>前面在讲解命令“sudo”的时候说过，“sudo”是以 root 用户身份执行一个命令，并没有更改当前的用户身份，所有需要 root 身份执行的命令都必须在前面加上“sudo”。命令“su”可以直接将当前用户切换为 root 用户，切换到 root 用户以后就可以尽情的进行任何操作了！因为你已经获得了系统最高权限，在 root 用户下，所有的命令都可以无障碍执行，不需要在前面加上“sudo”，“su”命令格式如下：<br>su [选项] [用户名]<br>常用选项参数如下：<br>-c –command 执行指定的命令，执行完毕以后回复原用户身份。<br>-login 改变用户身份，同时改变工作目录和 PATH 环境变量。<br>-m 改变用户身份的时候不改变环境变量<br>-h 显示帮助信息</p>
<h2 id="10-显示文件内容命令-cat"><a href="#10-显示文件内容命令-cat" class="headerlink" title="10.显示文件内容命令 cat"></a>10.显示文件内容命令 cat</h2><p>cat [选项] [文件]<br>选项主要参数如下：<br>-n 由 1 开始对所有输出的行进行编号。<br>-b 和-n 类似，但是不对空白行编号。<br>-s 当遇到连续两个行以上空白行的话就合并为一个行空白行。</p>
<h2 id="11-显示和配置网络属性命令-ifconfig"><a href="#11-显示和配置网络属性命令-ifconfig" class="headerlink" title="11.显示和配置网络属性命令 ifconfig"></a>11.显示和配置网络属性命令 ifconfig</h2><p>ifconfig 是一个跟网络属性配置和显示密切相关的命令，通过此命令我们可以查看当前网络<br>属性，也可以通过此命令配置网络属性，比如设置网络 IP 地址等等，此命令格式如下：<br>ifconfig interface options | address<br>主要参数如下：<br>interface 网络接口名称，比如 eth0 等。<br>up 开启网络设备。<br>down 关闭网络设备。<br>add IP 地址，设置网络 IP 地址。<br>netmask add 子网掩码。</p>
<h2 id="12-系统帮助命令-man"><a href="#12-系统帮助命令-man" class="headerlink" title="12.系统帮助命令 man"></a>12.系统帮助命令 man</h2><p>Ubuntu 系统中有很多命令，这些命令都有不同的格式，不同的格式对应不同的功能，要完全记住这些命令和格式几乎是不可能的，必须有一个帮助手册，当我们需要了解一个命令的详细信息的时候查阅这个帮助手册就行了。 Ubuntu 提供了一个命令来帮助用户完成这个功能，那就是“man”命令，通过“man”命令可以查看其它命令的语法格式、主要功能、主要参数说明等， “man”命令格式如下：<br>man [命令名]<br>比如我们要查看命令“ifconfig”的说明，输入“man ifconfig”即可。</p>
<h2 id="13-系统重启命令-reboot"><a href="#13-系统重启命令-reboot" class="headerlink" title="13.系统重启命令 reboot"></a>13.系统重启命令 reboot</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="14-系统关闭命令-poweroff"><a href="#14-系统关闭命令-poweroff" class="headerlink" title="14.系统关闭命令 poweroff"></a>14.系统关闭命令 poweroff</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure>

<h2 id="15-软件安装命令-install"><a href="#15-软件安装命令-install" class="headerlink" title="15.软件安装命令 install"></a>15.软件安装命令 install</h2><p>install [选项]… [-T] 源文件 目标文件<br>或： install [选项]… 源文件… 目录<br>或： install [选项]… -t 目录 源文件…<br>或： install [选项]… -d 目录…</p>
<p>“install”命令是将文件(通常是编译后的文件)复制到目的位置，在前三种形式中，将源文件复制到目标文件或将多个源文件复制到一个已存在的目录中同时设置其所有权和权限模式。在第四种形式会创建指定的目录。命令“install”通常和命令“apt-get”组合在一起使用的，关于“apt-get”命令我们稍后会讲解。</p>
<p>以上就是Ubuntu下Shell脚本的最基本命令，慢慢学习。</p>
]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux1-虚拟机及Ubuntu系统安装</title>
    <url>/2019/11/24/Linux1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8AUbuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h1><p>整个开发需要在windows电脑上安装虚拟机，在虚拟机中安装Linux操作系统</p>
<h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><p>虚拟机使用VMware 15pro，在官网下载完成直接安装，适用和激活自己看着办吧。<br>下载地址：<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html</a><br>网络上随便找的秘钥（亲测可用），随便找一个用吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8</span><br><span class="line">UG5J2-0ME12-M89WY-NPWXX-WQH88</span><br><span class="line">UA5DR-2ZD4H-089FY-6YQ5T-YPRX6</span><br><span class="line">GA590-86Y05-4806Y-X4PEE-ZV8E0</span><br><span class="line">ZF582-0NW5N-H8D2P-0XZEE-Z22VA</span><br><span class="line">YA18K-0WY8P-H85DY-L4NZG-X7RAD</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><h3 id="1-首先下载Ubuntu"><a href="#1-首先下载Ubuntu" class="headerlink" title="1.首先下载Ubuntu"></a>1.首先下载Ubuntu</h3><p>官网下载链接（本人下载Ubuntu18.04.3版本）：</p>
<p>  <a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a></p>
<h3 id="2-挂载到虚拟机中安装完成即可"><a href="#2-挂载到虚拟机中安装完成即可" class="headerlink" title="2.挂载到虚拟机中安装完成即可"></a>2.挂载到虚拟机中安装完成即可</h3><h2 id="学习适用Ubuntu操作系统"><a href="#学习适用Ubuntu操作系统" class="headerlink" title="学习适用Ubuntu操作系统"></a>学习适用Ubuntu操作系统</h2>]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-苦逼如我开始开发简介</title>
    <url>/2019/11/23/Linux-%E8%8B%A6%E9%80%BC%E5%A6%82%E6%88%91%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="说说我自己吧！！"><a href="#说说我自己吧！！" class="headerlink" title="说说我自己吧！！"></a>说说我自己吧！！</h1><p>作为一个毕业1年的本科学生也就是我本人，自从毕业之后一直还从事着电子类相关行业，会使用AD画一些图、会使用keil和一些开源软件写单片机代码；每个月拿着不多的工资、干着并不创新又重复操作的工作、生活在一个三四线又没有足够资金定居城市。毕业这一年每天都感到巨大的压力，从一个一心想转软件的小白到妥协搞嵌入式的渣渣，但是吧生活总是要继续的，总不能让明天过得比今天差吧，所以呢要坚持学习，相信付出总会有回报，坚持！！！！</p>
<h1 id="说说为什么要学嵌入式linux"><a href="#说说为什么要学嵌入式linux" class="headerlink" title="说说为什么要学嵌入式linux"></a>说说为什么要学嵌入式linux</h1><p>为什么要学linux呢，首先linux是一个世界级别的开源系统咱们就不在BB了，linux技术除了主要应用在服务器设备中，还在嵌入式行业占有很大的市场，通俗的再说一下吧，现在整个嵌入式除了单片机就是linux了，然后呢单片机主要面对的额是低端市场居多，嵌入式长期占领高端市场。那我们一个五六七八九十流的小公司来说吧，一个设备跑单片机完全能够解决所有问题，那还要花费巨大的人力和资金将设备转成linux操作系统的设备，就是为了个宣传假装高大上很多而已。说了这么多其实都是客套的在说，因为这不符合我的初衷啊，俺可是真的是热爱喜欢呢，大学就开始学习linux操作系统，Ubuntu系统一直在玩就是一直没有用武之地导致自己二半吊子的啥也不行，这次借助正点原子和野火这波风气必须好好搞一搞这个linux。</p>
<h1 id="说说我的准备吧"><a href="#说说我的准备吧" class="headerlink" title="说说我的准备吧"></a>说说我的准备吧</h1><p>为了学这个操作系统我在一年之前就买了一块核心吧，基于Cotex-A53架构的全志A64芯片做的一块核心板，这大半年一直想点亮呢，又由于各种事情没有进行下去，拓展板画好了很久很久也一直没有投出去焊接出来成品，这次是真的下定决心了，所以呢我吧自己画的板子做了一批件也买了一批，暂时只是没有时间焊接，等哪天挑出来个大片的时间把板子搞定再慢慢调吧。同时呢，我又买了一块野火的I.MX6ULL的开发板，画了几百票（想想千万不要为了省钱而不花钱投资自己的学习，你现在的话费和付出在将来一定会几倍、几十倍、几百倍的汇报回来）。</p>
<h1 id="说说开发板的选择吧"><a href="#说说开发板的选择吧" class="headerlink" title="说说开发板的选择吧"></a>说说开发板的选择吧</h1><p>这个开发板我可是选了很久很久，主要在正点原子和野火两家之间进行选择。我好的衡量了下还是野火的更适合我吧，屏幕的驱动转接板可以自己画，主要板载HDMI不要LCD也照样能看效果。话说这两家的套路还是很神的呢，很芯片做成了邮票边很明显不能再次更换核心了，BTB板接和金手指的还要再等他一个月，不过呢我忍了，就是个买吧，先好好地铺垫学习下等到板子回来之后就可以直接上手开发学习了；前边说的这个都是野火的板子，他的三个版本还是给大家留下了选择的余地了，再说说正点原子的吧，这个板子真的是让我又爱又气，虽然留下了BTB的核心板（显然是为了日后升级），但是呢只有LCD的屏幕接口（还是被改良过的只能用他们家的LCD液晶屏，显然不划算），没有HDMI接口还需后续购买，唯一让我能说好的就只是发货快，还能开发4G模组了。综合两个比较呢，还是野火的开发板更适合我了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上内容多数都为自己的观点，本片文章只是留给以后的自己看，在以后的日子中要为自己的这个开始做一个收尾。</p>
]]></content>
      <categories>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown4 列表</title>
    <url>/2019/10/14/Markdown4-%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1、Markdown-列表"><a href="#1、Markdown-列表" class="headerlink" title="1、Markdown 列表"></a>1、Markdown 列表</h1>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 段落格式</title>
    <url>/2019/10/14/Markdown3-%E6%AE%B5%E8%90%BD%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1、Markdown-段落"><a href="#1、Markdown-段落" class="headerlink" title="1、Markdown 段落"></a>1、Markdown 段落</h1><p>Markdown 段落没有特殊的格式，直接编写号文字就好， 段落的换行是使用两个以上的空格加上回车。  </p>
<p><img src="C:%5CUsers%5CS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571029888842.png" alt></p>
<p>也可以在段落后面使用一个空行来表示重新开始一个段落。</p>
<p><img src="C:%5CUsers%5CS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571029978682.png" alt="1571029978682"></p>
<h1 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h1><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示（源码下可以查看格式）：</p>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p>
<h1 id="3、分割线"><a href="#3、分割线" class="headerlink" title="3、分割线"></a>3、分割线</h1><p>可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。写法如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span><span class="bullet">* *</span></span><br><span class="line"></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示（md下可以查看源码格式）：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="4、删除线"><a href="#4、删除线" class="headerlink" title="4、删除线"></a>4、删除线</h1><p>如果段落上的文字需要添加删除线，只需要在文字两端加上两个波浪线’~~’即可，实例如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">你好</span><br><span class="line">~~你好~~</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：</p>
<p>hello<br>你好<br><del>你好</del>  </p>
<h1 id="5、下划线"><a href="#5、下划线" class="headerlink" title="5、下划线"></a>5、下划线</h1><p>下划线可以通过HTML的<u>标签来实现：</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后面为带下划线显示内容&lt;u&gt;I am a good dog!!!&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：</p>
<p>后面为带下划线显示内容<u>I am a good dog!!!</u>  </p>
<h1 id="6、脚注"><a href="#6、脚注" class="headerlink" title="6、脚注"></a>6、脚注</h1><p>脚注是对文本的补充说明。</p>
<p>Markdown脚注的格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^我是被脚注的部分]</span><br></pre></td></tr></table></figure>

<p>脚注实例如下用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先在文本后面添加脚注，想这样[^Haha]</span><br><span class="line">[^Haha]: 天道酬勤</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示（鼠标悬停在第一个脚注上即可显示下面的脚注内容）：  </p>
<p>先在文本后面添加脚注，想这样<a href="天道酬勤">^Haha</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中显式、隐式与explicit关键字</title>
    <url>/2019/10/09/C++-%E4%B8%AD%E6%98%BE%E5%BC%8F%E3%80%81%E9%9A%90%E5%BC%8F%E4%B8%8Eexplicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="C-中显式、隐式与explicit关键字"><a href="#C-中显式、隐式与explicit关键字" class="headerlink" title="C++中显式、隐式与explicit关键字"></a>C++中显式、隐式与explicit关键字</h1><p><strong><em>1.隐式转换</em></strong><br>隐式转换，即编译器完成的转换，例如<br>int a = 1;<br>float b = 3;<br>float sum;<br>sum = a + b;//a是int类型，b是float类型；在编译的时候，编译器自动将int a转换成了float类型</p>
<p><strong><em>2.显式转换</em></strong><br>显式转换，即用户完成的转换，例如<br>float a = 1;<br>float b = 3;<br>int s;<br>s = (int)a + (int)b;//float类型的a与b被显示的(强制)转换成成为float数据类型</p>
<p>对于非数据的函数函数而言，例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> x;</span><br><span class="line">　　<span class="keyword">public</span>:</span><br><span class="line">　　　　A()&#123;x=<span class="number">0</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Create A:0"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">　　　　A(<span class="keyword">int</span> a)&#123;x=a;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Create A:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">　　　　~A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Delete A:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　A a1;</span><br><span class="line">　　A *a2=<span class="keyword">new</span> A(<span class="number">10</span>);</span><br><span class="line">　　<span class="keyword">delete</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序分析：<br>A a1；隐式的调用了A();<br>A *a2 = new A(10);对A()进行了重载，显式的调用了A(int a);</p>
<p><strong><em>3.explicit关键字</em></strong></p>
<p>explicit用于构造函数，抑制隐式转换的发生，防止出现误区。</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中C++中文显示</title>
    <url>/2019/10/09/Qt-C++%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="Qt中C-中文显示"><a href="#Qt中C-中文显示" class="headerlink" title="Qt中C++中文显示"></a>Qt中C++中文显示</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;    //1.包含头文件</span></span></span><br><span class="line"></span><br><span class="line">QTextCodec *codec;     <span class="comment">//2声明一个全局变量</span></span><br><span class="line">codec = QtextCodec::codecForName(<span class="string">"GBK"</span>);    <span class="comment">//将编码格式声明为GBK</span></span><br><span class="line">ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode*(<span class="string">"中文"</span>));    <span class="comment">//将中文转换为为固定编码格式</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程</title>
    <url>/2019/10/09/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION CriticalSection;    <span class="comment">//防止共有资源被同时调用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;    <span class="comment">//定义一个变量初始值为10</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadOne</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"窗口1开始售票"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(&amp;CriticalSection);    <span class="comment">//进入临界状态</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"窗口1售出"</span> &lt;&lt; number;    <span class="comment">//打印出线程1抢占数值</span></span><br><span class="line">            number--;</span><br><span class="line">            Sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       LeaveCriticalSection(&amp;CriticalSection);    <span class="comment">//退出临界状态</span></span><br><span class="line">       Sleep(<span class="number">100</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadTwo</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"窗口2售票开始"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    EnterCriticalSection(&amp;CriticalSection);    <span class="comment">//进入线程临界状态</span></span><br><span class="line">    <span class="keyword">if</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"窗口2售出第"</span> &lt;&lt; number &lt;&lt; <span class="string">"张票"</span>；</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        number--;</span><br><span class="line">    &#125;</span><br><span class="line">    LeaveCriticalSection(&amp;CriticalSection);</span><br><span class="line">    Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE HOne,HTwo;</span><br><span class="line">    InitaializeCriticalSection(&amp;CriticalSection);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"*********vpoet******"</span>;</span><br><span class="line">    HOne = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadOne,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    HTwo = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadTwo,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(HOne);</span><br><span class="line">    CloseHandle(HTwo);</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"票没了！"</span></span><br><span class="line">            DeleCriticalSection(&amp;CriticalSection);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            coutinue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt+sqlite数据库连接</title>
    <url>/2019/10/09/Qt-sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Qt-sqlite数据库连接"><a href="#Qt-sqlite数据库连接" class="headerlink" title="Qt+sqlite数据库连接"></a>Qt+sqlite数据库连接</h1>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中QLineEdit的使用</title>
    <url>/2019/10/09/Qt-QLineEdit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="QLineEdit的使用"><a href="#QLineEdit的使用" class="headerlink" title="QLineEdit的使用"></a>QLineEdit的使用</h1><p>定义：<br>        QLineEdit是一个单行文本编辑控件。<br>功能：<br>        可以调用多个可用函数，输入和编辑单行文本，比如撤销、恢复、剪切、粘贴及拖放等。</p>
<p>函数说明：<br>    echoMode()：可以设置其属性，比如一密码的形式输入；<br>    maxLength()：限制文本长度；<br>    validator()或inputMask()：限制智能输入数字，在对同一个QLineEdit的validator或者inputmask进行转换时，最好将它的validator或者inputmask清楚，以避免错误发生；</p>
<p>与QLineEdit相关的一个类QTextEdit，她允许多行文本以及富文本编辑：<br>    setText()或者insert()改变其中的文本;<br>    text()：获得文本；<br>    displayText()：获得显示的文本；<br>    setSelection()或者selectAll()选中文本；<br>    cut()、copy()、paste()函数可以对文本中的数据进行剪切、复制和粘贴；<br>    setAlignment()：设置文本为位置；</p>
<p>信号反馈：<br>    文本改变信号：textChange();<br>    不是由setText()造成文本的改变信号：textEdit();<br>    鼠标光标改变时信号：cursorPostionChanged()；<br>    返回键或者回车键按下时信号：returnPressed();</p>
<p>常用方法说明：</p>
<p>1.setPlaceholderText()设置提示文字<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205204407710-892374169.jpg" alt="文本框提示文字"><br>豆瓣电影的搜索输入框，没有输入任何字符时，显示“电影、影人、影院、电视剧”这些占位文字，对用户输入作相关提示。<br>echoLineEdit-&gt;setPlaceholderText(“电影、影人、影院、电视剧”);</p>
<p>2.setEchoMode()设置模式<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205223926663-818638865.jpg" alt="淘宝"><br>淘宝登录界面的一部分，用户名可以直接看到，密码一般都用小黑点掩盖。</p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//默认,输入什么即显示什么</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">QLineEdit</span>::Normal);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="comment">//密码，一般用小黑点覆盖你所输入的字符</span></span><br><span class="line">             echoLineEdit-&gt;setEchoMode(<span class="attribute">QLineEdit</span>::Password);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">//编辑时输入字符显示输入内容否则用小黑点代替</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">QLintEdit</span>::PasswordEchoOnEdit);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">//任何输入都看不见（只是看不见，不是不能输入）</span></span><br><span class="line">            echoLineEdit-&gt;setEchoMode(<span class="attribute">ALineEdit</span>::NoEcho);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.setAlignment()设置文本位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::Alignleft);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::AlignCenter);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            alignmentLineEdit-&gt;setAlignment(Qt::AlignRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.setReadOnly()设置能否编辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            accessLineEdit-&gt;setReadOnly(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            accessLineEdit-&gt;setReadOnly(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.setValidator()对输入进行限制<br>这种方式的是指是通过正则表达式限制输入内容<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205224628272-1758708857.jpg" alt="输入限制"></p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//无限制</span></span><br><span class="line">            validatorLineEdit-&gt;setValidator(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">//只能输入整数</span></span><br><span class="line">            validatorLineEdit-&gt;setValidator(<span class="keyword">new</span> QintValidator);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">//实例，只能输入-180到180之间的小数，小数点后最多两位（可用于限制经纬度等）</span></span><br><span class="line">            QDoubleValodator *pDfValidator = <span class="keyword">new</span> QDoubleValidator(<span class="number">-180</span>, <span class="number">180.0</span>, <span class="number">2</span>, validatorLineEdit);</span><br><span class="line">            pDfValidator-&gt;setNotation(<span class="attribute">QDoubleValidator</span>::StandardNotation);</span><br><span class="line">            validatorLineEdit-&gt;setValidator(pDfValidator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.setInputMask()对输入进行限制<br>通过限制格式限制输入，具体怎么格式化客气参考Qt助手。<br><img src="https://images2015.cnblogs.com/blog/628412/201602/628412-20160205213813663-1721525219.jpg" alt="对输入进行限制"></p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"-99 99 99 99 99;_"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"0000-00-00"</span>);</span><br><span class="line">            inputMaskLineEdit-&gt;setText(<span class="string">"00000000"</span>);</span><br><span class="line">            inputMaskLineEdit-&gt;setCursorposition(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            inputMaskLineEdit-&gt;setInputMask(<span class="string">"&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.setLength()设置可以输入的最多字符数<br>//最多只能输入9个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echoLineEdit-&gt;setMaxLength(9);</span><br></pre></td></tr></table></figure>

<p>8.validator和inputmask的结合<br>比如经纬度用“度”</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt使Widget打开为全屏</title>
    <url>/2019/10/09/Qt-%E4%BD%BFWidget%E6%89%93%E5%BC%80%E4%B8%BA%E5%85%A8%E5%B1%8F/</url>
    <content><![CDATA[<h1 id="Qt5-5-1使Widget打开为全屏"><a href="#Qt5-5-1使Widget打开为全屏" class="headerlink" title="Qt5.5.1使Widget打开为全屏"></a>Qt5.5.1使Widget打开为全屏</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow w;</span><br><span class="line">w.showMaximized();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt信号与槽</title>
    <url>/2019/10/09/Qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</url>
    <content><![CDATA[<h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><p>简介：</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数和析构函数</title>
    <url>/2019/10/09/C++-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p><strong>构造函数</strong></p>
<p><strong>析构函数</strong><br>    构造函数（destructor）与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数用来做“清理善后”的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞与非阻塞的区别</title>
    <url>/2019/10/09/YY-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h1><p><strong>概念性理解：</strong><br>1.阻塞就是干不完不准回来；<br>2.非阻塞就是你先干，我现在看看有其他事没有，完了告诉我一声。</p>
<p><strong>以常用函数send和recv举例：</strong><br>    比如你调用send函数发送一定的Byte,在系统内部send做的工作其实只是把数据传输(Copy)到TCP/IP协议栈的输出缓冲区,它执行成功并不代表数据已经成功的发送出去了,如果TCP/IP协议栈没有足够的可用缓冲区来保存你Copy过来的数据的话…这时候就体现出阻塞和非阻塞的不同之处了:对于阻塞模式的socket send函数将不返回直到系统缓冲区有足够的空间把你要发送的数据Copy过去以后才返回,而对于非阻塞的socket来说send会立即返回WSAEWOULDDBLOCK告诉调用者说:”发送操作被阻塞了!!!你想办法处理吧…”<br>    对于recv函数,同样道理,该函数的内部工作机制其实是在等待TCP/IP协议栈的接收缓冲区通知它说:嗨,你的数据来了.对于阻塞模式的socket来说如果TCP/IP协议栈的接收缓冲区没有通知一个结果给它它就一直不返回:耗费着系统资源….对于非阻塞模式的socket该函数会马上返回,然后告诉你:WSAEWOULDDBLOCK—“现在没有数据,回头在来看看”</p>
<p><strong>概念性拓展：</strong><br>在进行网络编程时，我们常常见到同步、异步、阻塞和非阻塞四种调用方式。这些方式彼此概念并不好理解。下面是我对这些术语的理解。</p>
<p><em>同步</em><br>    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p>
<p><em>异步</em><br>    异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以 CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后，socket底 层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供 多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循 环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知 没太多区别。</p>
<p><em>阻塞</em><br>    阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p>
<p><em>非阻塞</em><br>    非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数</title>
    <url>/2019/10/09/C++-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<p><strong>函数定义格式</strong><br>C++ 中的函数定义的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<pre><code>返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。
函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
函数主体：函数主体包含一组定义函数执行任务的语句。</code></pre><p><strong>实例</strong><br>以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：<br>//函数返回两个数中较大那个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max( int num1, int num2 )</span><br><span class="line">&#123;</span><br><span class="line">    //局部变量声明</span><br><span class="line">    int result；</span><br><span class="line">    </span><br><span class="line">   if(num1 &gt; num2 )</span><br><span class="line">        result = num1;</span><br><span class="line">    else </span><br><span class="line">        result = num2;</span><br><span class="line">        </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数声明</strong><br>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。<br>函数声明包括以下几个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return_type function_name( parameter list );</span><br></pre></td></tr></table></figure>

<p>针对上面定义的函数 max()，以下是函数声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max(int num1, int num2);</span><br></pre></td></tr></table></figure>

<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max(int, int);</span><br></pre></td></tr></table></figure>

<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p><strong>函数调用</strong><br>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。<br>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用函数来获取最大值</span></span><br><span class="line">   ret = max(a, b);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max value is : "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回两个数中较大的那个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：<br>Max value is : 200</p>
<p><strong>函数参数</strong></p>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。<br>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。<br>当调用函数时，有两种向函数传递参数的方式：</p>
<p>调用类型：<br>传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。<br>指针调用：该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br>引用调用：该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p>
<p>默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p>
<p><strong>参数的默认值</strong></p>
<p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。<br>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = a + b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用函数来添加值</span></span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再次调用函数</span></span><br><span class="line">   result = sum(a);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total value is :"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>Total value is :300<br>Total value is :120</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用</title>
    <url>/2019/10/09/Qt-QT_BEGIN_NAMESPACE%E5%92%8CQT_END_NAMESPACE%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用"><a href="#Qt中QT-BEGIN-NAMESPACE与QT-END-NAMESPACE的作用" class="headerlink" title="Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用"></a>Qt中QT_BEGIN_NAMESPACE与QT_END_NAMESPACE的作用</h1><p> QT_BEGIN_NAMESPACE其实就是个宏，以前Qt4是没有命令空间的，后来才加上的，编译Qt源码时会有选项，是否将这些类放到专用的Qt命令空间内，默认是没有的。这就出来问题了，为了统一，如果你的代码在默认没有Qt命令空间的SDK中编译，那你就不用在前面加上命令空间，反之则需要。</p>
<p>为了屏蔽上面这个差异，使得你的代码能在这两种情况下都进行编译，Qt就提供了QT_BEGIN_NAMESPACE宏，这样开发者就省的自己来用程序或宏进行处理了。</p>
<p>至于说该宏提升编译速度什么的，那是上述类的声明的作用，与Qt无关的（也即与该宏QT_BEGIN_NAMESPACE无关），若要大幅提升编译速度需要开启qt的预编译头文件，会另起章节解说，并附测试结果。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#ifndef PREVIEWWINDOW_H</span><br><span class="line"></span><br><span class="line">#define PREVIEWWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"><span class="comment">// 方式一:</span></span><br><span class="line">#include &lt;QTextBrowser&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"><span class="comment">// 方式二:    比方式一可轻微提升编译速度</span></span><br><span class="line">class QTextBrowser;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line"><span class="comment">// 方式三:    编译速度与方式二一样，该宏用于自编译qt源码是否启动命令空间的补充</span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line">class QTextBrowser;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">class <span class="attribute">PreviewWindow</span> : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    explicit PreviewWindow(QWidget *<span class="built_in">parent</span> = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">signals</span>:</span><br><span class="line"></span><br><span class="line">public <span class="attribute">slots</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // PREVIEWWINDOW_H</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt设置背景界面</title>
    <url>/2019/10/09/Qt-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Qt设置背景界面"><a href="#Qt设置背景界面" class="headerlink" title="Qt设置背景界面"></a>Qt设置背景界面</h1><p>1.设置背景图片的一种方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(QString::fromUtf8(<span class="string">"./icon/background.png"</span>))</span></span>;<span class="comment">//当前文件夹下面的图片</span></span><br><span class="line">QPalette palette = <span class="keyword">this</span>-&gt;palette();</span><br><span class="line">palette.setBrush(backgroundRole(), QBrush(pixmap));</span><br><span class="line">setPalette(palette);</span><br></pre></td></tr></table></figure>

<p>2.使用Qt捕获windows窗口变化事件函数，自动调整背景缩放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> （当前函数所在类）::resizeEvent(QResizeEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(e);    <span class="comment">//不使用传入参数e，避免警告</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="keyword">this</span>-&gt;widght();    <span class="comment">//w为当前widght宽度</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="keyword">this</span>-&gt;height();    <span class="comment">//h为当前widght高度</span></span><br><span class="line">    QPixmap back_icon(QString::fromUtf8("资源路径"))；    //back_icon指向图片路径</span><br><span class="line">    QPlette.setBrush(<span class="keyword">this</span>-&gt;backgroundRole(),QBrush(back_icon.scaled(w,h)));    <span class="comment">//设置窗体背景和和缩放比例</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;setPalette(palette);    <span class="comment">//设置当前palette生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt常用控件的创建和使用</title>
    <url>/2019/10/09/Qt-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="常用控件的创建和使用"><a href="#常用控件的创建和使用" class="headerlink" title="常用控件的创建和使用"></a>常用控件的创建和使用</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;resize(<span class="number">600</span>,<span class="number">400</span>);  <span class="comment">//Set the window size</span></span><br><span class="line"></span><br><span class="line">    QMenuBar *bar = menuBar();  <span class="comment">//创建菜单栏,只能一个</span></span><br><span class="line">    setMenuBar(bar);    <span class="comment">//将菜单栏设置到窗口中</span></span><br><span class="line"></span><br><span class="line">    QMenu * fileMenu = bar-&gt;addMenu(<span class="string">"文件"</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;addMenu(<span class="string">"编辑"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加文件菜单项</span></span><br><span class="line">    QAction * createAction = fileMenu-&gt;addAction(<span class="string">"创建"</span>);</span><br><span class="line">    fileMenu-&gt;addSeparator();<span class="comment">//添加分割线</span></span><br><span class="line">    QAction * closeAction = fileMenu-&gt;addAction(<span class="string">"关闭"</span>);</span><br><span class="line">    fileMenu-&gt;addSeparator();<span class="comment">//添加分割线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加编辑菜单栏</span></span><br><span class="line">    QAction * copyAction = editMenu-&gt;addAction(<span class="string">"拷贝"</span>);</span><br><span class="line">    QAction * pasteAction = editMenu-&gt;addAction(<span class="string">"粘贴"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏 可以有很多个</span></span><br><span class="line">    QToolBar *toolBar = <span class="keyword">new</span> QToolBar(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将工具栏放入窗口中</span></span><br><span class="line">    addToolBar(Qt::LeftToolBarArea, toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只允许左右停靠</span></span><br><span class="line">    toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea</span><br><span class="line">                             | Qt::TopToolBarArea | Qt::BottomToolBarArea);</span><br><span class="line">    <span class="comment">//设置是否允许浮动</span></span><br><span class="line">    toolBar-&gt;setFloatable(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置是否允许移动</span></span><br><span class="line">    toolBar-&gt;setMovable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在工具栏中添加控件</span></span><br><span class="line">    QPushButton *btn = <span class="keyword">new</span> QPushButton(<span class="string">"按钮1"</span>,<span class="keyword">this</span>);</span><br><span class="line">    QPushButton *btn1 = <span class="keyword">new</span> QPushButton(<span class="string">"按钮2"</span>,<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;setStyleSheet(<span class="string">"QPushButton&#123;color:red&#125;"</span>);</span><br><span class="line">    QPushButton *btn2 = <span class="keyword">new</span> QPushButton(<span class="string">"按钮3"</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    toolBar-&gt;addWidget(btn);</span><br><span class="line">    toolBar-&gt;addSeparator();</span><br><span class="line">    toolBar-&gt;addWidget(btn1);</span><br><span class="line">    toolBar-&gt;addSeparator();</span><br><span class="line">    toolBar-&gt;addWidget(btn2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏，只有一个</span></span><br><span class="line">    QStatusBar * status = statusBar();</span><br><span class="line">    <span class="comment">//将状态栏放入到窗口中</span></span><br><span class="line">    setStatusBar(status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建标签</span></span><br><span class="line">    QLabel * label1 = <span class="keyword">new</span> QLabel(<span class="string">"左侧信息"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将label放入到状态栏中</span></span><br><span class="line">    status-&gt;addWidget(label1);</span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> QLabel(<span class="string">"右侧信息"</span>, <span class="keyword">this</span>);</span><br><span class="line">    status-&gt;addPermanentWidget(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 浮动窗口 可以多个</span></span><br><span class="line">    QDockWidget * dock = <span class="keyword">new</span> QDockWidget(<span class="string">"铆接部件"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将铆接部件放到窗体的核心部件的下方</span></span><br><span class="line">    addDockWidget(Qt::BottomDockWidgetArea, dock);</span><br><span class="line">    <span class="comment">//铆接部件设置停靠范文</span></span><br><span class="line">    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建核心部件 只能有一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> QTextEdit(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将文本编辑 放到窗体中间</span></span><br><span class="line">    setCentralWidget(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：直接使用set方法的窗口中只能有一个，使用add方法的窗口中可以有很多个</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内联函数(C++ inline)</title>
    <url>/2019/10/09/C++-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0(C++%20inline)/</url>
    <content><![CDATA[<h1 id="C-内联函数-C-inline"><a href="#C-内联函数-C-inline" class="headerlink" title="C++内联函数(C++ inline)"></a>C++内联函数(C++ inline)</h1><p>使用函数能够避免将相同代码重写多次的麻烦，还能减少可执行程序的体积，但也会带来程序运行时间上的开销。</p>
<p>函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。</p>
<p>另外，函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址继续执行，这个过程也要耗费时间。</p>
<p>总之，使用函数调用语句和直接把函数中的代码重新抄写一遍相比，节省了人力，但是带来了程序运行时间上的额外开销。</p>
<p>一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。</p>
<p>作为特别注重程序执行效率，适合编写底层系统软件的高级程序设计语言，C++ 用 inline 关键字较好地解决了函数调用开销的问题。</p>
<p>在 C++ 中，可以在定义函数时，在返回值类型前面加上 inline 关键字。如： </p>
<pre><code>inline int Max (int a, int b)
{
    if(a &gt;b)
        return a;
    return b;
}</code></pre><p>增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。</p>
<p>有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。</p>
<p>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。</p>
<p>有时函数看上去很简单，例如只有一个包含一两条语句的循环，但该循环的执行次数可能很多，要消耗大量时间，那么这种情况也不适合将其实现为内联函数。</p>
<p>注意：的是，调用内联函数的语句前必须已经出现内联函数的定义（即整个数体），而不能只出现内联函数的声明！</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/09/YY-#pragma%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="pragma预处理指令"><a href="#pragma预处理指令" class="headerlink" title="#pragma预处理指令"></a>#pragma预处理指令</h1><p><strong><em>定义：</em></strong><br>在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。</p>
<p><strong><em>一般格式：</em></strong></p>
<p>#pargam Para        其中Para为参数</p>
<p><strong>举例</strong><br><em>1.message参数：</em><br>    Message 参数能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：</p>
<p>   #pragma message(“消息文本”)</p>
<p>   当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。<br>   当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法<br>    #ifdef _X86<br>    #pragma message(“_X86 macro activated!”)<br>    #endif</p>
<p>当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示“_X86 macro activated! ”。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。</p>
<p><em>2.code_seg存放代码段：</em></p>
<p>code_seg对pragma的使用量也比较大</p>
<p>#pragma code_seg([“section-name”[,”section-class”]])</p>
<p>它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。</p>
<p>3.pragma once 执行一次（常用）<br>    只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。<br>    #pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。<br>    #ifndef，#define，#endif这个是C++语言相关，这是C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式</p>
<p>附件链接：<a href="https://baike.baidu.com/item/%23pragma/706691?fr=aladdin#1_10" target="_blank" rel="noopener">pragma百度百科</a></p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt多线程实例</title>
    <url>/2019/10/08/Qt-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="多线程实例"><a href="#多线程实例" class="headerlink" title="多线程实例"></a>多线程实例</h1><p><strong>使用QThread类，实现Qt多线程</strong></p>
<p>方法：使用一个类继承QThread，然后重新改写虚函数run()。</p>
<p><strong>使用moveToThread，实现Qt多线程</strong></p>
<p>通过这种方法不需要继承QThread,重写run()函数来实现Qt多线程，而是通过moveToThread(QThread *thread)函数将工作累对象移到所创建的QThread对象中去执行。利用信号与槽机制。</p>
<p>程序结构：<br>1.在主程序中，那里需要多线程就在哪里创建一个QThread实例；<br>2.把耗时操作封装到一个继承QObject的子类</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 标题</title>
    <url>/2019/10/08/Markdown2-%E6%A0%87%E9%A2%98/</url>
    <content><![CDATA[<p>Mrakdown 标题有两种格式。</p>
<h1 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用=和 - 标记一级和二级标题"></a>1、使用=和 - 标记一级和二级标题</h1><p>=和-标记语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一级标题展示</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">这是二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<p>效果如下（在源码格式下查看格式）：</p>
<h1 id="这是一级标题展示"><a href="#这是一级标题展示" class="headerlink" title="这是一级标题展示"></a>这是一级标题展示</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h1 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用#号标记"></a>2、使用#号标记</h1><p>使用‘#’号可以表一1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下所示（可以在源码格式下查看详细格式）：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>两个冒号的作用</title>
    <url>/2019/10/08/C++-%E2%80%9C%EF%BC%9A%EF%BC%9A%E2%80%9D%E4%B8%A4%E4%B8%AA%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="“：：”两个冒号的作用"><a href="#“：：”两个冒号的作用" class="headerlink" title="“：：”两个冒号的作用"></a>“：：”两个冒号的作用</h1><p>“::”在C++中表示作用域，和所属关系。”::”是运算符中登记最高的，它分为三种，如下：</p>
<p>一、作用域符号<br>作用域符号”::”的前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。</p>
<p>例如：A、B表示两个类，在A、B中都有成员member<br>那么：<br>        1、A::member就表示类A中的成员member；<br>        2、B::member就表示类B中的成员member；</p>
<p>二、全局作用域符号<br>全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，例如：<br>char zhou；    //全局变量<br>void    sleep()<br>{<br>    char zhou;    //局部变量<br>    char(局部变量) = char(局部变量) * char(局部变量);<br>    ::char(全局变量) = ::char(全局变量) * ::char(全局变量)；<br>}</p>
<p>三、作用域分解运算符<br>::是C++里的作用域分解运算符，比如类说明了一个类A，类A里声明了一个成员函数void f(),但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成void A :: f();表示这个f()函数是类A的成员函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CA&#123;</span><br><span class="line">public :</span><br><span class="line">    int ca_var;</span><br><span class="line">    int add（int a, int b）;</span><br><span class="line">    int add(int a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>//那么在实现这个函数时候，必须要这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int CA::add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int CA::add(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return a + :: ca_var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//表示当前类实例中的变量ca_var;</p>
]]></content>
      <categories>
        <category>YY</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown教程</title>
    <url>/2019/10/08/Markdown1-%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="img" style="zoom: 50%;">

<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown语言在2004年由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。</p>
<p>Markdown编写的文档后缀名为.md, ,markdown。</p>
<h1 id="Markdown应用"><a href="#Markdown应用" class="headerlink" title="Markdown应用"></a>Markdown应用</h1><p>Markdown 能被使用来撰写电子书，如：Gitbook。<br>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>本教程将使用 Typora 编辑器来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。<br>支持导出HTML、PDF、Word、图片等多种类型文件。</p>
<p>Typora 官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p>
<p>你也可以使用在线编辑器来测试：<a href="https://c.runoob.com/front-end/712。" target="_blank" rel="noopener">https://c.runoob.com/front-end/712。</a></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
